<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tree API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tree</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from pathlib import Path
import numpy as np

from src.fileorganiser.general import *

from src.fileorganiser.globals import *



    

# ======================================================== #
# ======================== PRUNING ======================= #
# ======================================================== #
&#34;&#34;&#34;
Functionality for excluding/including specific files/folders from the search. 

Appending additional excluded folders with each search
iteration unused within django interface.
&#34;&#34;&#34;

# Prune the tree (dataframes) to include only the specified file/folder paths
# Produces pruned dataframes for files/folders 
def PruneTree(tree:Tree, folderResults:list[Path], fileResults:list[Path]):
    &#39;&#39;&#39; 
    Description
    -----------
    Given a list of matched file and folders (from a fuzzy dataframe search) remove all unmatched files/folders in the tree.

    Subfolders/files of any matched folders are still included.  
    
    Args:
    -----
        tree: Tree
            #: The tree to prune
        folderResults : list[Path]
            #: The list of folder paths to keep
        fileResults : list[Path]
            #: The list of any extra file paths to keep
        
    Outputs
    -------
        prunedFolderDf : pd.Dataframe
            #: Dataframe containing only the matched folders (and any subfolders)
        prunedFileDf : pd.Dataframe
            #: Dataframe containing matched files, and any files within matched folders
        prunedJson : [str]
            #: JSON string array for the pruned tree
    &#39;&#39;&#39;
    
    
    includedFiles = list()
    includedFolders = list()
  
    if(folderResults):
        # Get the corresponding fobject class 
        includedFolders = [ParseFobject(path) for path in folderResults]
        # Make sure all subdirs are included (and not duplicated)
        for folder in includedFolders:
            for subdir in folder.subdirs:
                # Ensure no duplicates added
                if(subdir not in includedFolders):
                    includedFolders.append(subdir)
        
        # Include all files in the included folders
        for folder in includedFolders:
            includedFiles.extend(folder.files)
        
        includedFolderPaths = [ParsePath(folder) for folder in includedFolders]
        includedFilePaths = [ParsePath(file) for file in includedFiles]
    
    if(fileResults):
        # Add any extra files found by the search if not already added 
        extraIncludedFiles = [path for path in fileResults if path not in includedFilePaths]
        includedFilePaths.extend(extraIncludedFiles)
        includedFiles.extend([ParseFobject(path) for path in extraIncludedFiles])
    
    # Slice the dataframes using the included files/folders FIXME: remove unnecessary extra parsepaths
    prunedFolderDf = tree.folderDf.loc[[ParsePath(path).as_posix() for path in includedFolderPaths]]
    prunedFileDf = tree.fileDf.loc[[ParsePath(path).as_posix() for path in includedFilePaths]]

    prunedJson = PrunedSubtreesJSON(includedFolders, extraIncludedFiles)

    return prunedFolderDf, prunedFileDf, prunedJson


# Create the subtree JSON strings from the pruned results
def PrunedSubtreesJSON(includedFolders, extraIncludedFiles):
    &#39;&#39;&#39; 
    Description
    -----------
    Create the JSON required to represent the pruned tree as a jsTree instance. 
    
    Folder structure of included folders is represented, in addition to any extra matched files (these are shown within the root folder of the tree in this instance)  
    
    Args:
    -----
        
        includedFolders : list[Folder]
            #: The list of folders included
        extraIncludedFiles : list[File]
            #: The list of any extra file paths included
        
    Outputs
    -------
        allJson : [str]
            #: JSON string array for the pruned tree
    &#39;&#39;&#39;
    allJson = list()

    folderPaths = [ParsePath(folder) for folder in includedFolders]
    
    # Form all the included folders 
    for folder in includedFolders:
        # Check if this folder should be a tree root (no parent included)
        if(ParsePath(folder.parent) not in folderPaths):
            allJson.append(IndividualJstreeJson(folder, isTree=True))
        else:
            # Use the already calculated Json string (still valid)
            allJson.append(folder.jstreeJson)
        # Add all pre-existing file strings (all have valid parent - this folder)
        allJson.extend([file.jstreeJson for file in folder.files])
    # Add any extra files that are not within any included folders
    for file in extraIncludedFiles:
        allJson.append(IndividualJstreeJson(file, isTree=True))

    return allJson


# Use to remove the excluded folders from the total list to scan
def RemoveExcludedFolders(allFoldersList, excludedPaths):
    &#39;&#39;&#39; 
    Description
    -----------
    Removes any requested folders from the total list of folders to scan.  
    
    Args:
    -----
        allFoldersList : list[Folder]
            #: The list of all folders currently included
        excludedPaths : list[Path]
            #: The list of any folder paths to exclude
        
    Outputs
    -------
        allFoldersList : list[Folder]
            #: The list of all folders currently included
    &#39;&#39;&#39;
    if(len(excludedPaths) &gt; 0):
        blacklist = [ParsePath(exc).as_posix() for exc in excludedPaths]

        for excFolder in excludedPaths:
            
            allSubdirs = ListFolderContents(excFolder, allSubdirs=True)
            for sub in allSubdirs:
                if sub is not None:
                    blacklist.extend({ParsePath(sub).as_posix()})
        idx = 0
        # Need to repeatedly loop through list from beginning when deleting elements (could possibly optimise this) 
        while idx &lt; len(allFoldersList):
            #print(idx)
            name = ParsePath(allFoldersList[idx]).as_posix() 
            if(name in blacklist):
                del allFoldersList[idx]
            else:
                idx +=1
        return allFoldersList
    # Do nothing if no excluded paths 
    return allFoldersList 


# ======================================================== #
# ============== UNUSED IN DJANGO INTERFACE ============== #
# ======================================================== #

# # Append the configuration with additional excluded folders - neds dict to avoid duplicating folders
# def appendExcludedRoots(config, appendFile):
#     try:
#         with appendFile as f:
#             appendRootPaths = f.readlines()
        
#     except:
#         print(&#34;Exception encountered opening append file&#34;)
        
#         return     
    
#     finally:  
#         if(len(appendRootPaths) == 0):
#             return
        
#         for pathStr in appendRootPaths:
#             path = ParsePath(pathStr)
#             # Add the root path to the excluded list (to display)
#             config.excludedPaths.append(path)
#             # Add all the subdirs to the total excluded list
#             config.excludedPaths.extend(ListFolderContents(path, allSubdirs=True))
#         # Remove the newly excluded fingerprints
#         removeOldFingerprints(config)
    
            
# def removeOldFingerprints(config):
#     global PATH_DICT
#     # Remove all files from the FpFilesDict
#     for path in config.excludedPaths:        
#         path = ParsePath(path)
#         if path in config.pathDict:
#             folder = config.pathDict[path]
#             for file in folder.files:
#                 if(file.fpString in config.log.FpFilesDict):
#                     files = config.log.FpFilesDict[file.fpString]
#                     files.remove(file)
#                 if(file.fpString in config.log.FpList):
#                     config.log.FpList.remove(file.fpString)
#         else:
#             print(&#34;Trying to remove fingerprint from path not in dict!&#34;)


# ======================================================== #
# =================== OLD TREE DIAGRAM =================== #
# ======================================================== #

&#34;&#34;&#34;A recursive generator, given a directory Path object
    will yield a visual tree structure line by line
    with each line prefixed by the same characters
    &#34;&#34;&#34;  
# #  noFiles - only draw subdirs in tree  
# def draw_tree_line(dir_path, prefix: str=&#39;&#39;, noFiles = False):
#     # prefix components:
#     space =  &#39;    &#39;
#     branch = &#39;│   &#39;
#     # pointers:
#     tee =    &#39;├── &#39;
#     last =   &#39;└── &#39; 
      
#     dir_path = ParsePath(dir_path)
    
#     # Old method for listing contents
#     #contents = list(dir_path.iterdir())
    
#     # Get the contents to draw, sort by descending netsize (includes filesizes) 
#     sortedContents = list() 
    
#     subdirs = [PATH_DICT[path] for path in ListSubdirs(dir_path)]
#     sortedContents.extend(sortbySizeDesc(subdirs))
#     # Files in the folder    
#     if(not noFiles):
#         files = PATH_DICT[dir_path].files
#         sortedContents.extend(sortbySizeDesc(files))
#     # Sort all subdirs and files into size order 
#     sortedContents = sortbySizeDesc(sortedContents)
#     # Extract the corresponding paths
#     sortedPaths = [ParsePath(content) for content in sortedContents]
    
     
#     # contents each get pointers that are ├── with a final └── :
#     pointers = [tee] * (len(sortedPaths) - 1) + [last]
    
#     for pointer, path in zip(pointers, sortedPaths):
#         yield   prefix + pointer + path.name + WriteStorageInfo(path) + &#34;\n&#34;
#         if path.is_dir(): # extend the prefix and recurse:
#             extension = branch if pointer == tee else space 
#             # i.e. space because last, └── , above so no more |
#             yield from draw_tree_line(path, prefix=prefix+extension)


# def generate_tree_lines(root):
#     root = ParsePath(root)
#     lines = []
    
#     # Generate all tree lines
#     for line in draw_tree_line(root):
#         lines.extend({line})
#     return lines


# def draw_tree(root, outPath):
    
#     lines = generate_tree_lines(ParsePath(root))
#     # Write all lines to file
#     outFile = outPath / (&#34;TreeStructure.txt&#34;)
#     with open(outFile, &#34;w+&#34;, encoding=&#39;utf-8&#39;) as writer:
#         writer.write(str(root.as_posix()) + WriteStorageInfo(root) + &#34;\n&#34; + f&#34;{&#39;├─&#39; + &#39;─&#39;*200}&#34; + &#34;\n&#34;)
#         writer.writelines(lines)




# # Return a list of all directories sorted by size (top or net)
# def sort_all_dirs(tree, topLevel = True):
    
#     #allDirs = [pathDict[dir] for dir in list_folder_contents(tree.rootFolder, allSubdirs=True)]
#     allDirs = list()
#     for dir in ListFolderContents(tree.rootFolder, allSubdirs=True):
#         if dir in PATH_DICT:
#             allDirs.append(dir)
#         else:
#             print(&#34;Directory not in path dict!&#34; + str(ParsePath(dir).as_posix()))
    
#     allSortedDirs = sortbySizeDesc(allDirs, topLevel=topLevel)
#     return allSortedDirs

# def write_sorted_dirs(config, topLevel=True):
    
    
#     for tree in config.trees:
        
#         outFile = config.runPath / (&#34;DirectorySizes_&#34; + f&#34;{tree.rootFolder.path.name}&#34; +&#34;.txt&#34;)
        
#         allSortedDirs = sort_all_dirs(tree, topLevel=topLevel)
        
#         with open(outFile, &#34;w+&#34;) as writer:
#             writer.write(&#34;Subdirectories in: &#34; + str(ParsePath(tree.rootFolder).as_posix()) + &#34;\n&#34;) 
#             writer.write(&#34;Total size: &#34; + str(size(tree.rootFolder.netSize))+ &#34;\n&#34;)
            
#             if(topLevel):
#                 writer.write(&#34;Top-level sizes: &#34; + f&#34;\n{&#39;-&#39;*100}\n&#34; )
#             else:
#                 writer.write(&#34;Net sizes: &#34; + f&#34;\n{&#39;-&#39;*100}\n&#34;)
            
#             for dir in allSortedDirs:
#                 if(topLevel):
#                     writer.write(&#34;(&#34; + str(size(dir.topSize)) + &#34;) #: &#34; + str( ParsePath(dir).as_posix()) +&#34;\n&#34;)

#                 else:
#                     writer.write(&#34;(&#34; + str(size(dir.netSize)) + &#34;) #: &#34; + str( ParsePath(dir).as_posix()) +&#34;\n&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tree.PruneTree"><code class="name flex">
<span>def <span class="ident">PruneTree</span></span>(<span>tree: src.fileorganiser.general.Tree, folderResults: list, fileResults: list)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Given a list of matched file and folders (from a fuzzy dataframe search) remove all unmatched files/folders in the tree.</p>
<p>Subfolders/files of any matched folders are still included.
</p>
<h2 id="args">Args:</h2>
<pre><code>tree: Tree
    #: The tree to prune
folderResults : list[Path]
    #: The list of folder paths to keep
fileResults : list[Path]
    #: The list of any extra file paths to keep
</code></pre>
<h2 id="outputs">Outputs</h2>
<pre><code>prunedFolderDf : pd.Dataframe
    #: Dataframe containing only the matched folders (and any subfolders)
prunedFileDf : pd.Dataframe
    #: Dataframe containing matched files, and any files within matched folders
prunedJson : [str]
    #: JSON string array for the pruned tree
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PruneTree(tree:Tree, folderResults:list[Path], fileResults:list[Path]):
    &#39;&#39;&#39; 
    Description
    -----------
    Given a list of matched file and folders (from a fuzzy dataframe search) remove all unmatched files/folders in the tree.

    Subfolders/files of any matched folders are still included.  
    
    Args:
    -----
        tree: Tree
            #: The tree to prune
        folderResults : list[Path]
            #: The list of folder paths to keep
        fileResults : list[Path]
            #: The list of any extra file paths to keep
        
    Outputs
    -------
        prunedFolderDf : pd.Dataframe
            #: Dataframe containing only the matched folders (and any subfolders)
        prunedFileDf : pd.Dataframe
            #: Dataframe containing matched files, and any files within matched folders
        prunedJson : [str]
            #: JSON string array for the pruned tree
    &#39;&#39;&#39;
    
    
    includedFiles = list()
    includedFolders = list()
  
    if(folderResults):
        # Get the corresponding fobject class 
        includedFolders = [ParseFobject(path) for path in folderResults]
        # Make sure all subdirs are included (and not duplicated)
        for folder in includedFolders:
            for subdir in folder.subdirs:
                # Ensure no duplicates added
                if(subdir not in includedFolders):
                    includedFolders.append(subdir)
        
        # Include all files in the included folders
        for folder in includedFolders:
            includedFiles.extend(folder.files)
        
        includedFolderPaths = [ParsePath(folder) for folder in includedFolders]
        includedFilePaths = [ParsePath(file) for file in includedFiles]
    
    if(fileResults):
        # Add any extra files found by the search if not already added 
        extraIncludedFiles = [path for path in fileResults if path not in includedFilePaths]
        includedFilePaths.extend(extraIncludedFiles)
        includedFiles.extend([ParseFobject(path) for path in extraIncludedFiles])
    
    # Slice the dataframes using the included files/folders FIXME: remove unnecessary extra parsepaths
    prunedFolderDf = tree.folderDf.loc[[ParsePath(path).as_posix() for path in includedFolderPaths]]
    prunedFileDf = tree.fileDf.loc[[ParsePath(path).as_posix() for path in includedFilePaths]]

    prunedJson = PrunedSubtreesJSON(includedFolders, extraIncludedFiles)

    return prunedFolderDf, prunedFileDf, prunedJson</code></pre>
</details>
</dd>
<dt id="tree.PrunedSubtreesJSON"><code class="name flex">
<span>def <span class="ident">PrunedSubtreesJSON</span></span>(<span>includedFolders, extraIncludedFiles)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Create the JSON required to represent the pruned tree as a jsTree instance. </p>
<p>Folder structure of included folders is represented, in addition to any extra matched files (these are shown within the root folder of the tree in this instance)
</p>
<h2 id="args">Args:</h2>
<pre><code>includedFolders : list[Folder]
    #: The list of folders included
extraIncludedFiles : list[File]
    #: The list of any extra file paths included
</code></pre>
<h2 id="outputs">Outputs</h2>
<pre><code>allJson : [str]
    #: JSON string array for the pruned tree
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PrunedSubtreesJSON(includedFolders, extraIncludedFiles):
    &#39;&#39;&#39; 
    Description
    -----------
    Create the JSON required to represent the pruned tree as a jsTree instance. 
    
    Folder structure of included folders is represented, in addition to any extra matched files (these are shown within the root folder of the tree in this instance)  
    
    Args:
    -----
        
        includedFolders : list[Folder]
            #: The list of folders included
        extraIncludedFiles : list[File]
            #: The list of any extra file paths included
        
    Outputs
    -------
        allJson : [str]
            #: JSON string array for the pruned tree
    &#39;&#39;&#39;
    allJson = list()

    folderPaths = [ParsePath(folder) for folder in includedFolders]
    
    # Form all the included folders 
    for folder in includedFolders:
        # Check if this folder should be a tree root (no parent included)
        if(ParsePath(folder.parent) not in folderPaths):
            allJson.append(IndividualJstreeJson(folder, isTree=True))
        else:
            # Use the already calculated Json string (still valid)
            allJson.append(folder.jstreeJson)
        # Add all pre-existing file strings (all have valid parent - this folder)
        allJson.extend([file.jstreeJson for file in folder.files])
    # Add any extra files that are not within any included folders
    for file in extraIncludedFiles:
        allJson.append(IndividualJstreeJson(file, isTree=True))

    return allJson</code></pre>
</details>
</dd>
<dt id="tree.RemoveExcludedFolders"><code class="name flex">
<span>def <span class="ident">RemoveExcludedFolders</span></span>(<span>allFoldersList, excludedPaths)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Removes any requested folders from the total list of folders to scan.
</p>
<h2 id="args">Args:</h2>
<pre><code>allFoldersList : list[Folder]
    #: The list of all folders currently included
excludedPaths : list[Path]
    #: The list of any folder paths to exclude
</code></pre>
<h2 id="outputs">Outputs</h2>
<pre><code>allFoldersList : list[Folder]
    #: The list of all folders currently included
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RemoveExcludedFolders(allFoldersList, excludedPaths):
    &#39;&#39;&#39; 
    Description
    -----------
    Removes any requested folders from the total list of folders to scan.  
    
    Args:
    -----
        allFoldersList : list[Folder]
            #: The list of all folders currently included
        excludedPaths : list[Path]
            #: The list of any folder paths to exclude
        
    Outputs
    -------
        allFoldersList : list[Folder]
            #: The list of all folders currently included
    &#39;&#39;&#39;
    if(len(excludedPaths) &gt; 0):
        blacklist = [ParsePath(exc).as_posix() for exc in excludedPaths]

        for excFolder in excludedPaths:
            
            allSubdirs = ListFolderContents(excFolder, allSubdirs=True)
            for sub in allSubdirs:
                if sub is not None:
                    blacklist.extend({ParsePath(sub).as_posix()})
        idx = 0
        # Need to repeatedly loop through list from beginning when deleting elements (could possibly optimise this) 
        while idx &lt; len(allFoldersList):
            #print(idx)
            name = ParsePath(allFoldersList[idx]).as_posix() 
            if(name in blacklist):
                del allFoldersList[idx]
            else:
                idx +=1
        return allFoldersList
    # Do nothing if no excluded paths 
    return allFoldersList </code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fileorganiser" href="index.html">fileorganiser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tree.PruneTree" href="#tree.PruneTree">PruneTree</a></code></li>
<li><code><a title="tree.PrunedSubtreesJSON" href="#tree.PrunedSubtreesJSON">PrunedSubtreesJSON</a></code></li>
<li><code><a title="tree.RemoveExcludedFolders" href="#tree.RemoveExcludedFolders">RemoveExcludedFolders</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>