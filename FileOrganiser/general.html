<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>general API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>general</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from pathlib import Path
import numpy as np
import pandas as pd
import shutil
import os
import time
import datetime
from hurry.filesize import size, alternative

import json

from src.fileorganiser.globals import *

import src.fileorganiser.tagging as tag
#from src.fileorganiser.tagging import TagFileByExtension

# ====================================================== #
# ==================== CONFIGURATION =================== #
# ====================================================== #

# Folder names to ignore if ignoreProgramFolders is true

IGNORED_FOLDERS = [&#39;$RECYCLE.BIN&#39;, &#39;Program Files&#39;, &#39;Program Files (x86)&#39;, &#39;ProgramData&#39;, &#39;AppData&#39;, &#39;Windows&#39;, &#39;Windows.old&#39;]


# Object to hold current duplicate search configuration

class Config():
    &#34;&#34;&#34;
        Class:
        ------------
        Class that stores the configuration of the duplicate search. 
        Contains preset size (1000 bytes) for the size clustering threshold.

    &#34;&#34;&#34;
    def __init__(self, sizeThreshold=0, depth=-1, included=None, excluded=None):
        &#34;&#34;&#34;
            Description:
            ------------
            Constructor for the Config class. Takes no input, kwargs specify default settings and included/excluded folders if specified.

            Inputs:
            -------
            Kwargs:
            -------
                sizeThreshold : int : default=0
                    #: Threshold (bytes) below which to ignore files
                depth : int : default=-1
                    #: Specifies the search depth (-1 = all)
                included : list[path]
                    #: List of paths to include (only those listed are used)
                excluded : list[path]
                    #: List of paths to exclude
        &#34;&#34;&#34;
    # -------- Default settings -------- #
        # All paths to include (if not whole tree)
        if(included != None):
            self.includedPaths = [ParsePath(inc) for inc in included]
        else:
            self.includedPaths = list()
        # Stored trees
        self.trees = list() 
        # Folders to exclude (absolute paths)
        self.excludedPaths = list()
        if(excluded != None):
            # Ensure blank strings are omitted
            for exc in excluded:
                if(exc != &#39;&#39;):
                    self.excludedPaths.append(ParsePath(exc))
        
        # Folder to hold this search run and append file (set after construct)
        self.runPath = None
        self.appendFile = None
        # Size threshold (files below this will be ignored)
        self.sizeThreshold = sizeThreshold
        # Cluster threshold when clustering files by size (bytes)
        self.clusterThreshold = 1000
        # Extensions to ignore 
        self.excludedExt = list()
        # Search depth (-1 = everything, 0 = current folder only, 1 = folder + subfolders only, etc)
        self.depth = depth
        # Dupe log associated with this config
        self.log = Log()
        # Set config on dupeLog
        self.log.config = self
        # Master path dict (set after construct)
        self.pathDict = None
        # Similarity threshold (default at 100%)
        self.similarityThreshold = 1 

# Used to store the results of a single duplicate finding pass
class Log():
    &#34;&#34;&#34;
        Class:
        ------------
        Class that stores the results of a single duplicate finding run. 
        Contains lists of duplicate fingerprints, and dicts that store scores of similar folders.
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
            Description:
            ------------
            Constructor for the Log class. Takes no input
        &#34;&#34;&#34;
        # Configuration object associated with this log 
        self.config = None
        
        self.startTime = time.time()
        self.elapsedTime = 0

        # List of folders scanned
        self.scannedFolders = list()
        # Dict of file fingerprint -&gt; file(s) (list of file(s) with that fingerprint)
        self.FpFilesDict = dict()
        # List of all fingerprints to check
        self.FpList = list()
        # List of duplicated fingerprints (to be calculated)
        self.dupeFpList = list()
        # List of individual fingerprint logs
        self.dupeFpLogList = list()
        # Dict containing all folder pairs -&gt; similarity scores (to avoid double counting)
        self.similarPairScoresDict = dict()
        # Dict containing base folder pair -&gt; recursive parent pairs
        self.allPairRecursiveScores = dict()
        # Total duplicate storage scanned
        self.totDupeStorage = 0
        # Total storage scanned
        self.totScannedStorage = 0
        # Tot files ignored (below threshold)
        self.filesIgnored = 0

# ======================================================== #
# ===================== CLASS OBJECTS ==================== #
# ======================================================== #

&#34;&#34;&#34;
Class objects to store file and folder information.

Throughout the documentation, the file and folder classes will collectively be referred to as `fobjects&#39;
when considering anything applicable to either object. 

&#34;&#34;&#34;

# File object
class File():
    &#34;&#34;&#34;
        Class:
        ------------
        Class that represents an individual file and holds various attributes derived from the path. netSize is the file size.
        If the file cannot be accessed (FileNotFoundError exception) this is logged in the tree object.
    &#34;&#34;&#34;
    
    def __init__(self, path, tree=None):
        &#34;&#34;&#34;
            Description:
            ------------
            Constructor for the File class. Takes the file pathlike object as input.
            
                        
            Inputs:
            -------
            Args:
            -----
                path : pathlike object
                    #: The pathlike object of the file path
            
            Kwargs:
            -------
                tree : Tree : default=None
                    #: Reference to the tree this file is within
                
            
        &#34;&#34;&#34;
        
        #print(&#34;constructed file: &#34; + str(parsePath(path)))
        global PATH_DICT
        # Filepath
        self.path = ParsePath(path)
        # Path string (for dataframe)
        self.pathStr = self.path.as_posix()
        # Add to path dict
        PATH_DICT[self.path] = self
        # Master tree this file belongs to (if specified)
        if(tree):
            self.tree = tree
        # Filename
        self.name = self.path.stem
        # Parent folder
        self.parent = self.path.parent.as_posix()
        # Extension
        self.extension = self.path.suffix
        # Fingerprint string
        self.fingerprint = None
        # File size #: called netSize for cross compatibility (in generic file/folder methods asking for size netSize = filesize for a file)
        try:
            self.netSize = self.path.stat().st_size
        except FileNotFoundError:
            print(&#34;The file could not be accessed! #: &#34; + self.path.absolute().as_posix())
            # Remove this file from the dict before continuing 
            del PATH_DICT[self.path]
            if(tree):
                tree.fileExceptions.append(self)
            return None

        # Calculate the required JSON string for jsTree
        self.jstreeJson = IndividualJstreeJson(self)


        # ---------- TAGS ---------- #
        # List of all tags associated to this file
        self.tags = list()
        # Basic type tag determined from the extension (also stored in the tags list but has separate reference for easy access)
        self.extensionSubtypeStr = tag.TagByExtensionSubtype(self).tagName

    # String representation (for easy debugging - replaces unreadable memory addresses)
    def __repr__(self):
        return &#34;&lt;File: .../&#34; + self.path.parent.as_posix() +&#34;/&#34; + self.path.name +&#34;&gt;&#34;
        

        
# Folder object, recursively constructs subfolders if makeAllSubdirs=True 
class Folder():
    &#34;&#34;&#34;
        Class:
        ------------
        Class that represents an individual folder. Contains references to all subfolder objects and the files within this folder.
    &#34;&#34;&#34;
    def __init__(self, path, makeAllSubdirs=True, isTree=False, tree=None, ignoreProgramFolders=True):
        &#34;&#34;&#34;
            Description:
            ------------
            Constructor for the Folder class. Takes the folder pathlike object as input.
            Constructing the folder recursively builds all subfolders and file objects.
                        
            Inputs:
            -------
            Args:
            -----
                path : pathlike object
                    #: The pathlike object of the folder path
            
            Kwargs:
            -------
                makeAllSubdirs : bool : default=True
                    #: If true, recursively construct all subdirectories
                isTree : bool : default=False
                    #: Signifies if this folder is also a tree root
                tree : Tree : default=None
                    #: Reference to the tree this folder is within
                ignoreProgramFolders : bool : default=True
                    #: If true, exclude folders whose name matches those in the EXCLUDED_FOLDERS constant
            
        &#34;&#34;&#34;
        # For modifying the pathDict
        global PATH_DICT
        # Folder path
        self.path = ParsePath(path)
        # Path string (for dataframe)
        self.pathStr = self.path.as_posix()
        # Name
        self.name = self.path.stem
        # Parent folder
        self.parent = self.path.parent.as_posix()
        # Master tree this folder belongs to
        self.tree = tree
        # Add to path dict
        PATH_DICT[self.path] = self
        # Use to signify if this folder represents an entire tree
        self.isTree = isTree

        self.files = list()
        self.subdirs = list()
        
        # Add all files in folder to list 
        _files, _subdirs = ListFolderContents(path, allSubdirs=False, ignoreProgramFolders=ignoreProgramFolders)
        # Must first check if not None - since len(None) gives error
        if(_files != None and len(_files) != 0):
            for f in _files:
                filePath = Path(self.path / Path(f))
                file = File(filePath, tree=self.tree)
                # File will have no netsize if exception thrown when constructing - do not include in file list
                try:
                    _test = file.netSize
                    self.files.append(file)
                except AttributeError:
                    print(&#34;File has no net size, ignoring&#34;)
                    continue
        if(_subdirs != None and len(_subdirs) != 0):
            if(makeAllSubdirs):
                # Create all subfolders (recursively call Folder constructor on subdirs)
                for sdir in _subdirs:
                    sdirPath = Path(self.path / Path(sdir))
                    subdir = Folder(sdirPath, makeAllSubdirs=True, tree=self.tree)
                    self.subdirs.append(subdir)
        
        # Calculate net and top sizes of this folder
        calculate_storage(self)
        
        # Sort the list of files in descending order (optional, but useful later)
        self.files = sortbySizeDesc(self.files)

        # Create the JSON string for this jsTree node
        self.jstreeJson = IndividualJstreeJson(self)

        # Tags for this folder
        self.tags = list()

        

    # String representation (for easy debugging - replaces unreadable memory addresses)
    def __repr__(self):
        return &#34;&lt;Folder: .../&#34; + self.path.name +&#34;&gt;&#34;


# Calculate storage for this folder (Net and Top sizes)
# If called when constructing a folder, the folder constructor must have already populated the list of files
def calculate_storage(self:Folder):
    self.topSize = 0
    self.netSize = 0
    # File contribution to size
    for file in self.files:
        try:
            self.topSize += file.netSize
            #print(&#34;File was ok&#34;)
        except AttributeError:
            print(&#34;File had no attributes set!&#34; + str(file) )
    
    self.netSize = self.topSize
    # Subdir contribution to net size
    if(len(self.subdirs) != 0):
        for subdir in self.subdirs:
            self.netSize += subdir.netSize
    


# Use to construct an entire file tree from a single root - convenience to differentiate between a folder instance and an entire tree
class Tree():
    &#34;&#34;&#34;
        Class:
        ------------
        Class that represents the entire file system tree. Contains a reference to the tree root folder (that recursively contains all subfolder and file objects)
        Contains the file and folder dataframes that represent the entire file system
    &#34;&#34;&#34;
    
    
    def __init__(self, root, ignoreProgramFolders=True):
        &#34;&#34;&#34;
            Description:
            ------------
            Constructor for the Tree class. Takes the tree root pathlike object as input.
            Constructing the tree root folder recursively builds the tree with all subfolders and files
            Builds the file and folder dataframes once the file/folders are built
            
            Inputs:
            -------
            Args:
            -----
                root : pathlike object
                    #: The pathlike object of the tree root folder
            
            Kwargs:
            -------
                ignoreProgramFolders : bool : default=True
                    #: If true, exclude folders whose name matches those in the EXCLUDED_FOLDERS constant
            
        &#34;&#34;&#34;
        
        startTime = time.time()
        self.rootPath = ParsePath(root)
        
        global PATH_DICT
        # Clear the dict to avoid issues when constructing higher level tree after a subtree was constructed (subtree root would already be in dict and so the new tree would simply return the subtree as the root folder)
        PATH_DICT.clear()

        # Clear any previous fobject associations in the tag tree
        tag.ClearPreviousTags()

        # List of files that threw exceptions when reading size 
        self.fileExceptions = list()

        # Recursively build all the folders starting from this root         
        self.rootFolder = Folder(self.rootPath, makeAllSubdirs=True, isTree=True, tree=self, ignoreProgramFolders=ignoreProgramFolders)

        # Build the file and folder dataframes 
        self.folderDf = None
        self.fileDf = None
        BuildDataframes(self)
        self.buildTime = (time.time()-startTime)/60
        print(&#34;Tree built in &#34; + f&#34;{self.buildTime:2.2f}&#34; + &#34;minutes&#34;)
   

# Build searchable dataframes of all files and folders in the tree
def BuildDataframes(tree:Tree):
    &#34;&#34;&#34;
        Description:
        ------------
        Builds dataframes that contain all File and Folder objects within the tree (separate File and Folder dataframes).
        The dataframes are indexed using the absolute (posix) path string.
        The specified dataframe columns are built from the fobject attributes using the fobject.\_\_dict\_\_ object.
        Called on tree construction once all files and folders built

        
        Args:
        -----
            tree : Tree
                #: The tree object containing all files and folders to parse into the dataframe
        
        Outputs:
        --------
            None
                #: Dataframes are directly set on the Tree instance passed (this method called on construction)
    &#34;&#34;&#34;
    # List of dicts for each set of row values
    folderRows = list()
    fileRows = list()

    # For extracting specific keys in the class attributes dict - colName must match class attribute name
    folderCols = (&#34;pathStr&#34;, &#34;name&#34;, &#34;parent&#34;, &#34;netSize&#34;, &#34;topSize&#34;, &#34;subdirs&#34;, &#34;files&#34;)
    fileCols = (&#34;pathStr&#34;, &#34;name&#34;, &#34;parent&#34;, &#34;netSize&#34;, &#34;extension&#34;, &#34;fingerprint&#34;, &#34;extensionSubtypeStr&#34;)

    # Loop through pathDict and add dict of attributes to main lists    
    for path in PATH_DICT:
        fobject = ParseFobject(path)
        if(isinstance(fobject, File)):
            # Extract the desired keys into a dummy dict and add to file rows
            fileRows.append(dict((key, fobject.__dict__[key]) for key in fileCols))
        if(isinstance(fobject, Folder)):
            # Extract the desired keys into a dummy dict and add to folder rows
            folderRows.append(dict((key, fobject.__dict__[key]) for key in folderCols))
    
    folderIndex = [rowDict[&#34;pathStr&#34;] for rowDict in folderRows]
    fileIndex = [rowDict[&#34;pathStr&#34;] for rowDict in fileRows]

    # Construct the dataframes using the list of dicts 
    tree.folderDf = pd.DataFrame(folderRows, index=folderIndex, dtype=&#34;string&#34;)
    tree.fileDf = pd.DataFrame(fileRows, index=fileIndex, dtype=&#34;string&#34;)
    
# Build JSON using the indexes returned from a df query 
# Does not use df directly but instead accesses the fobject instance using the df index - FIXME: optimise to use df only
def JsonFromPaths(dfIndices:list[str]):

    fobjects = [ParseFobject(index) for index in dfIndices]

    allJsonStrings = [IndividualJstreeJson(fobject) for fobject in fobjects]

    return allJsonStrings
    



# Generate the JSON for a single node (file or folder)
def IndividualJstreeJson(object, isTree=False):
    &#34;&#34;&#34;
        Description:
        ------------
        Generate the jsTree JSON string for an individual fobject (including size info string). 
        Sets required attributes in the JSONDict and dumps the result to a JSON string.
        Specifies icon based on input fobject type.
        Called on fobject construction once attributes set, string stored as fobject attribute.

        
        Args:
        -----
            object : File or Folder
                #: The fobject to generate JSON for
        
        Kwargs:
        -------
            isTree : bool : default=False
                #: Only true if this fobject is the absolute tree root (to set parent = &#39;#&#39;)

        Outputs:
        --------
            JSONstring : str 
                #: JSON string required for jsTree
    &#34;&#34;&#34;

    path = ParsePath(object)
    
    # Set the id as the absolute path (guaranteed to be unique)
    id = path.as_posix()
    # Set the parent id using the absolute path of the parent 
    parent = path.parent.as_posix()
    
    # Set the correct icon
    if(isinstance(object, Folder)):
        icon = &#34;fas fa-folder-open&#34;
        if(object.isTree or isTree):
            # Specify this node is a root
            parent = &#34;#&#34;
    else:
        icon = &#39;fas fa-file&#39;
        if(isTree):
            parent = &#34;#&#34;
    
    JSONdict = {
        &#34;id&#34;          : id,             # required
        &#34;parent&#34;      : parent,         # required
        &#34;icon&#34;        : icon,
        &#34;text&#34;        : str(path.name) + WriteStorageInfo(object),
        &#34;a_attr&#34;     : {&#34;style&#34;:&#34;font-size:20px&#34;}
    }
    JSONstring = json.dumps(JSONdict)
    return JSONstring
    
    
# Go through entire pathdict and return all JSON strings (could be optimised by doing this step on construction - needs some global reference to the tree however)
def AllJstreeJson(pathDict):
    &#34;&#34;&#34;
        Description:
        ------------
        Loop through the PATH_DICT and collate all jsTree json strings into single array

        
        Args:
        -----
            pathDict : dict
                #: The global path dict

        Outputs:
        --------
            allJson : [str] 
                #: String array with all jsTree json strings
    &#34;&#34;&#34;
    
    allJson = list()
    #arrayDict = dict()
    for idx, path in enumerate(pathDict):
        string = pathDict[path].jstreeJson
        allJson.extend({string}) 
        #arrayDict[idx] = string
    
    return allJson

# Produce the string with Top: and Net: size information
def WriteStorageInfo(object):
    &#34;&#34;&#34;
        Description:
        ------------
        Given a fobject this writes the string with top and net size information. Uses size from hurry.filesize to convert to readable size

        
        Args:
        -----
            object : File or Folder
                #: File or Folder object (sizes stored in top and net size attributes)

        Outputs:
        --------
            info : str 
                #: The string with size information

        Notes:    
        ------
        File size is stored in an attribute called &#34;netSize&#34; to match the netSize attribute of folders - to allow methods to reference this property that allow both file and folder object inputs 
    &#34;&#34;&#34;

    path = ParsePath(object)
    object = PATH_DICT[path]
    # Only write netSize (filesize) if file
    if(isinstance(object, File)):
        info = &#34; #: (&#34; + str(size(object.netSize)) + &#34;)&#34;
    # Write top and net sizes for folder
    if(isinstance(object, Folder)):
        info = &#34; #: (Top: &#34; + str(size(object.topSize)) + &#34;, Net: &#34; + str(size(object.netSize)) + &#34;)&#34;
    return info


# ======================================================== #
# =================== FOLDER UTILITIES =================== #
# ======================================================== #

&#34;&#34;&#34; General utilities for returning lists of folder contents &#34;&#34;&#34;


# Helper function to parse path/string/file/folder object into the respective path object
def ParsePath(path):
    &#34;&#34;&#34;
        Description:
        ------------
        Given either a pathlike string, path, or fobject this returns (or generates given a pathlike string) the associated Path object.

        
        Args:
        -----
            object : str, Path, File or Folder
                #: Accepts any of the above types that may represent the desired path

        Outputs:
        --------
            output : Path 
                #: The Path object associated with the passed object

        Notes:    
        ------
        Possible optimisation could remove this function in places where the object is guaranteed to already be of Path type. 
    &#34;&#34;&#34;
    
    if(isinstance(path, str)):
        path = Path(path)
    elif(isinstance(path, Path)):
        return path
    elif(isinstance(path, File) or isinstance(path, Folder)):
        path = path.path
    elif(isinstance(path, Tree)):
        path = ParsePath(path.rootFolder)
    else: 
        print(&#34;Invalid path type! Type: &#34; + str(type(path)))
        return None
    return path   



# Checks if the path exists on the file system
def validPath(path):
    &#34;&#34;&#34;
        Description:
        ------------
        Checks whether the given path is valid (exists on the filesystem)

        
        Args:
        -----
            path : pathlike object
                #: Uses ParsePath to convert any pathlike input to the underlying Path

        Outputs:
        --------
            output : bool 
                #: True if the path exists on the filesystem
        
    &#34;&#34;&#34;

    path = ParsePath(path)
    if(not os.path.exists(path)):
        print(&#34;Invalid directory - &#34; + str(path))
        return False
    return True

# Parse the fobject given a path or fobject, using the pathDict. If not valid fobject or not in pathDict returns None 
def ParseFobject(object):
    &#34;&#34;&#34;
        Description:
        ------------
        Given either a pathlike string, path, or fobject this returns the associated fobject (using the global PATH_DICT).
        If no corresponding object exists this returns None.

        
        Args:
        -----
            object : str, Path, File or Folder
                #: Accepts any of the above types that may represent the desired fobject

        Outputs:
        --------
            output : File, Folder or None 
                #: The file or folder instance returned from the PATH_DICT lookup - if not found returns None

        Notes:    
        ------
        Possible optimisation could remove this function in places where the object is guaranteed to already be of fobject type. 
    &#34;&#34;&#34;
    if(isinstance(object, str)):
        try:
            fobject = PATH_DICT[ParsePath(object)]
            return fobject
        except KeyError:
            print(&#34;Object was not found in dict! - &#34; + str(object))
            return None
    if(isinstance(object, Path)):
        if(object in PATH_DICT):
            fobject = PATH_DICT[object]
            return fobject
        else:
            print(&#34;Path was not found in dict! - &#34; + str(object.as_posix()))
            return None
    if(isinstance(object, File) or isinstance(object, Folder)):
        return object

# if allSubdirs = False : Returns two lists, one with sub-directories and one with all files in root
# if allSubdirs = True : Returns list of ALL subdirs from this root 
def ListFolderContents(path, allSubdirs=True, noFiles=False, ignoreProgramFolders=True):
    &#34;&#34;&#34;
        Description:
        ------------
        Produces a list of all filenames and separate list of all subdirectory names within the folder passed.

        
        Args:
        -----    
            path : str
                #: Pathlike string of folder to search within 

        Kwargs:
        -------
            allSubdirs : bool : default=True
                #: Specify whether the list should penetrate into all subdirectories - if false returns toplevel files/subdirs only
            noFiles : bool : default=False
                #: If true, output list of subdirectories only
            ignoreProgramFolders : bool : default=True
                #: Specify whether to exclude any folders whose name matches those folders specified in the IGNORED_FOLDERS constant 

        Outputs:
        ------------
        
            filenames : list[str] 
                #: List of all file path strings contained in all relevant folders (dependent on allSubdirs)
            allSubfoldersList : list[str]
                #: List of all subfolder path strings (max depth)
            subfolderList : list[str]
                #: If allSubdirs=False this returns toplevel subdirs only

    &#34;&#34;&#34;
    
    
    # Check if valid directory
    path = ParsePath(path)
    if(not validPath(path)):
        return None, None
    
    allSubfoldersList = list()
    filenames = None
    subfolderList = list()
    for (root, subdirs, filenames) in os.walk(path):
        
        # Check if walked into an excluded folder
        rootPath = ParsePath(root)
        for excluded in IGNORED_FOLDERS:
            if(excluded in rootPath.parts):
                continue


        if(not allSubdirs):
            for subdir in subdirs:
                subPath = ParsePath(root) / ParsePath(subdir)
                # Check if this is an ignored program folder
                if(ignoreProgramFolders and subPath.name in IGNORED_FOLDERS):
                    # Skip to next subdir in loop
                    continue
                # Folder safe to include
                subfolderList.extend({subPath})
            # Break after first walk, don&#39;t go down into subdirs
            break 
        
        if(allSubdirs):
            for subdir in subdirs:
                subPath = ParsePath(root) / ParsePath(subdir)
                # Check if this is an ignored program folder
                if(ignoreProgramFolders and subPath.name in IGNORED_FOLDERS):
                    # Skip to next subdir in loop
                    continue
                # Folder safe to include
                allSubfoldersList.extend({subPath})
            # Continue walk into subdirs
            continue

    if(not allSubdirs):
        if(noFiles):
            return subfolderList
        return filenames, subfolderList

    if(allSubdirs):
        return allSubfoldersList


# Return list of subdirs in this root 
def ListSubdirs(root):
    return ListFolderContents(root, allSubdirs=False, noFiles=True)


# Returns list of all subdirs up to a maximum depth from the root
def ListSubdirsAtDepth(root, maxDepth):
    &#34;&#34;&#34;
        Description:
        ------------
        Produces a list all subdirectories at the specified depth within the root folder passed.

        
        Args:
        -----    
            root : Pathlike str or Folder object
                #: List of folder objects to find files within (toplevel only) 
            maxDepth : int
                #: Furthest depth to penetrate into subdirs - 0 = toplevel, 1 = first subdirs, 2 = subdirs of subdirs etc.

        Outputs:
        ------------
            allSubdirsList : list[Folder] 
                #: List of all folder objects found within the maxDepth

    &#34;&#34;&#34;
    
    rootPath = ParsePath(root)
    
    # Override for returning all subdirs - FIXME - clean up returning paths and folders 
    if(maxDepth == -1):
        return [PATH_DICT[ParsePath(path)] for path in ListFolderContents(root, allSubdirs=True)]

    allSubdirsList = list()
    
    # rootSubdirs = list_subdirs(rootPath)
    
    # if(rootSubdirs != None and len(rootSubdirs)&gt;0):
    #     allSubdirsList.extend(rootSubdirs)
    
    for currRoot, subdirs, files in os.walk(rootPath, topdown=True):
        # Calculate root depth by counting difference in part sizes between root and current path 
        depth =  len(ParsePath(currRoot).parts) - len(ParsePath(root).parts)
        
        if depth &lt; maxDepth:
            # Less than, since listing subdirs of the current depth - any subdir will be one depth further than the current depth
            # e.g. if maxDepth was zero (top level of folder) want no subdirs which would have depth 1.
            # Do nothing if no subdirs
            if(len(subdirs) == 0):
                continue
            # Not yet at maximum depth, parse all subdir paths and add to list
            allFolders = [PATH_DICT[ParsePath(currRoot) / ParsePath(subdir)] for subdir in subdirs]
            allSubdirsList.extend( allFolders )
            if(depth == maxDepth):
                # Don&#39;t recurse any further
                subdirs[:] = []
    
    #print(allSubdirsList)
    return allSubdirsList


# Returns list of all files contained in the top level of a given list of folders
def ListAllToplevelFiles(folders:list):
    &#34;&#34;&#34;
        Description:
        ------------
        Produces a list all files contained in the top level of all folders passed.

        
        Args:
        -----    
            folders : list[Folder]
                #: List of folder objects to find files within (toplevel only) 

        Outputs:
        ------------
            allFiles : list[File] 
                #: List of all file objects contained in all passed folders

    &#34;&#34;&#34;

    # Ensure passed list of folders
    folders = [ParseFobject(folder) for folder in folders]
    # List all files in each folder and add to master list
    allFiles = list()
    for folder in folders:
        allFiles.extend(folder.files)
    
    # Return list of file objects
    return allFiles


# ======================================================== #
# ===================== UTILITIES ======================== #
# ======================================================== #


# Sort a list of fobjects in descending size order based on net size contents
def sortbySizeDesc(unsortedObjects:list, topLevel=False):
    &#34;&#34;&#34;
        Description:
        ------------
        Sort a list of fobjects in descending size order. Kwarg topLevel only relevant for folders (sort by topLevel as opposed to netSize).

        
        Args:
        -----
            unsortedObjects : list[File or Folder]
                #: List of fobjects to be sorted

        Kwargs:
        -------
            topLevel : bool : default=False
                #: If true and fobjects are Folders, sort by topLevel not netSizes
        
        Outputs:
        --------
            sortedList : list[File or Folder] 
                #: The sorted (descending order) list of files
    &#34;&#34;&#34;
    if(len(unsortedObjects) == 0):
        return unsortedObjects
    sizes = []
    sortedList = list()
    for object in unsortedObjects:
        # Ensure toplevel = False if object is a file 
        if(isinstance(object, File)):
            topLevel = False
        # Record net or toplevel size
        if(not topLevel):
            sizes.extend({object.netSize}) # netSize = filesize if object is file
        if(topLevel):
            sizes.extend({object.topSize}) # sort by toplevel size only (objects must be folders)
    # Sort by descending size
    sortedArgs = np.flip(np.argsort(sizes))
    for i in range(len(sizes)):
        sortedList.append(unsortedObjects[sortedArgs[i]])
    return sortedList


# Sort a list of items by their common value property: list((item, value))
def SortItemValueList(itemValueList, desc=False):
    &#34;&#34;&#34;
        Description:
        ------------
        Sort a list of pairs of the form (item, value) based on the value. 

        
        Args:
        -----
            itemValueList : list[tuple]
                #: List of pairs (item, value) to be sorted

        Kwargs:
        -------
            desc : bool : default=False
                #: If true, sort in descending order
        
        Outputs:
        --------
            sortedItemsList : list[tuple] 
                #: The sorted list of (item, value) pairs
    &#34;&#34;&#34;
    values = [itemValue[1] for itemValue in itemValueList]
    indices = np.argsort(values)
    if(desc):
        indices = np.flip(indices)
    sortedItemsList = list()
    for idx in indices:
        sortedItemsList.append(itemValueList[idx][0])
    return sortedItemsList




# Used to make a new folder in the root dir with consecutively numbered name, eg run_2, run_3 etc
# Checks for folder called folderName_X and creates it if not already exists
# root must be Path object
def makeNewConsecutiveFolder(root, folderName):
    &#34;&#34;&#34;
        Description:
        ------------
        Make a new folder within the specified root with consecutively increasing numbering of the form folderName_#

        
        Args:
        -----
            root : pathlike object or fobject
                #: Folder to create new folders within
            folderName : str
                #: Name of the new folders to create, eg &#39;run&#39; would create folders run_1, run_2 etc
        
        
        Outputs:
        --------
            #: Path to newly created folder
            
    &#34;&#34;&#34; 
    
    root = ParsePath(root)
    # Make root directory if not already exist
    os.makedirs(root, exist_ok=True)
        
        # Ensure folder name ends with underscore _
    name = str(folderName)
    if(name[len(name)-1] != &#34;_&#34;):
       name = name + r&#34;_&#34;
        
        # Test for already created folders with correct name
    n=1
    test_dir = root / (name + str(n))
    while (os.path.exists(test_dir)):
        n += 1
        test_dir = root / (name + str(n))
        # Create new folder with _n
    os.makedirs(test_dir)
        
    return Path(test_dir)


# Parse a csv string into a list of strings
def parseCSVstring(csvString:str):
    &#34;&#34;&#34;
        Description:
        ------------
        Parse a comma separated value string into a list of values.

        
        Args:
        -----
            csvString : str
                #: String containing comma separated values
                    
        Outputs:
        --------
            splitList : list[str]
                #: List of values
            
    &#34;&#34;&#34;     
    splitList = [split.strip() for split in csvString.split(&#34;,&#34;) if split != &#39;&#39;]
    if(len(splitList) == 0):
        return None
    if(len(splitList) == 1 and splitList[0] == &#39;&#39;):
        return None
    return splitList
    
    



# # Create a folder instance of a zipped folder - unzip to parent directory of zip and make folder instance
# def folder_from_zip(zip_path):
#     shutil.unpack_archive(zip_path, zip_path.parent)
#     unzip_path = zip_path.parent / zip_path.stem 
#     zip_folder = Folder(unzip_path, makeAllSubdirs=False)
#     return zip_folder








    
                </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="general.AllJstreeJson"><code class="name flex">
<span>def <span class="ident">AllJstreeJson</span></span>(<span>pathDict)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Loop through the PATH_DICT and collate all jsTree json strings into single array</p>
<h2 id="args">Args:</h2>
<pre><code>pathDict : dict
    #: The global path dict
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>allJson : [str] 
    #: String array with all jsTree json strings
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AllJstreeJson(pathDict):
    &#34;&#34;&#34;
        Description:
        ------------
        Loop through the PATH_DICT and collate all jsTree json strings into single array

        
        Args:
        -----
            pathDict : dict
                #: The global path dict

        Outputs:
        --------
            allJson : [str] 
                #: String array with all jsTree json strings
    &#34;&#34;&#34;
    
    allJson = list()
    #arrayDict = dict()
    for idx, path in enumerate(pathDict):
        string = pathDict[path].jstreeJson
        allJson.extend({string}) 
        #arrayDict[idx] = string
    
    return allJson</code></pre>
</details>
</dd>
<dt id="general.BuildDataframes"><code class="name flex">
<span>def <span class="ident">BuildDataframes</span></span>(<span>tree:Â <a title="general.Tree" href="#general.Tree">Tree</a>)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Builds dataframes that contain all File and Folder objects within the tree (separate File and Folder dataframes).
The dataframes are indexed using the absolute (posix) path string.
The specified dataframe columns are built from the fobject attributes using the fobject.__dict__ object.
Called on tree construction once all files and folders built</p>
<h2 id="args">Args:</h2>
<pre><code>tree : Tree
    #: The tree object containing all files and folders to parse into the dataframe
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>None
    #: Dataframes are directly set on the Tree instance passed (this method called on construction)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BuildDataframes(tree:Tree):
    &#34;&#34;&#34;
        Description:
        ------------
        Builds dataframes that contain all File and Folder objects within the tree (separate File and Folder dataframes).
        The dataframes are indexed using the absolute (posix) path string.
        The specified dataframe columns are built from the fobject attributes using the fobject.\_\_dict\_\_ object.
        Called on tree construction once all files and folders built

        
        Args:
        -----
            tree : Tree
                #: The tree object containing all files and folders to parse into the dataframe
        
        Outputs:
        --------
            None
                #: Dataframes are directly set on the Tree instance passed (this method called on construction)
    &#34;&#34;&#34;
    # List of dicts for each set of row values
    folderRows = list()
    fileRows = list()

    # For extracting specific keys in the class attributes dict - colName must match class attribute name
    folderCols = (&#34;pathStr&#34;, &#34;name&#34;, &#34;parent&#34;, &#34;netSize&#34;, &#34;topSize&#34;, &#34;subdirs&#34;, &#34;files&#34;)
    fileCols = (&#34;pathStr&#34;, &#34;name&#34;, &#34;parent&#34;, &#34;netSize&#34;, &#34;extension&#34;, &#34;fingerprint&#34;, &#34;extensionSubtypeStr&#34;)

    # Loop through pathDict and add dict of attributes to main lists    
    for path in PATH_DICT:
        fobject = ParseFobject(path)
        if(isinstance(fobject, File)):
            # Extract the desired keys into a dummy dict and add to file rows
            fileRows.append(dict((key, fobject.__dict__[key]) for key in fileCols))
        if(isinstance(fobject, Folder)):
            # Extract the desired keys into a dummy dict and add to folder rows
            folderRows.append(dict((key, fobject.__dict__[key]) for key in folderCols))
    
    folderIndex = [rowDict[&#34;pathStr&#34;] for rowDict in folderRows]
    fileIndex = [rowDict[&#34;pathStr&#34;] for rowDict in fileRows]

    # Construct the dataframes using the list of dicts 
    tree.folderDf = pd.DataFrame(folderRows, index=folderIndex, dtype=&#34;string&#34;)
    tree.fileDf = pd.DataFrame(fileRows, index=fileIndex, dtype=&#34;string&#34;)</code></pre>
</details>
</dd>
<dt id="general.IndividualJstreeJson"><code class="name flex">
<span>def <span class="ident">IndividualJstreeJson</span></span>(<span>object, isTree=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Generate the jsTree JSON string for an individual fobject (including size info string).
Sets required attributes in the JSONDict and dumps the result to a JSON string.
Specifies icon based on input fobject type.
Called on fobject construction once attributes set, string stored as fobject attribute.</p>
<h2 id="args">Args:</h2>
<pre><code>object : File or Folder
    #: The fobject to generate JSON for
</code></pre>
<h2 id="kwargs">Kwargs:</h2>
<pre><code>isTree : bool : default=False
    #: Only true if this fobject is the absolute tree root (to set parent = '#')
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>JSONstring : str 
    #: JSON string required for jsTree
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IndividualJstreeJson(object, isTree=False):
    &#34;&#34;&#34;
        Description:
        ------------
        Generate the jsTree JSON string for an individual fobject (including size info string). 
        Sets required attributes in the JSONDict and dumps the result to a JSON string.
        Specifies icon based on input fobject type.
        Called on fobject construction once attributes set, string stored as fobject attribute.

        
        Args:
        -----
            object : File or Folder
                #: The fobject to generate JSON for
        
        Kwargs:
        -------
            isTree : bool : default=False
                #: Only true if this fobject is the absolute tree root (to set parent = &#39;#&#39;)

        Outputs:
        --------
            JSONstring : str 
                #: JSON string required for jsTree
    &#34;&#34;&#34;

    path = ParsePath(object)
    
    # Set the id as the absolute path (guaranteed to be unique)
    id = path.as_posix()
    # Set the parent id using the absolute path of the parent 
    parent = path.parent.as_posix()
    
    # Set the correct icon
    if(isinstance(object, Folder)):
        icon = &#34;fas fa-folder-open&#34;
        if(object.isTree or isTree):
            # Specify this node is a root
            parent = &#34;#&#34;
    else:
        icon = &#39;fas fa-file&#39;
        if(isTree):
            parent = &#34;#&#34;
    
    JSONdict = {
        &#34;id&#34;          : id,             # required
        &#34;parent&#34;      : parent,         # required
        &#34;icon&#34;        : icon,
        &#34;text&#34;        : str(path.name) + WriteStorageInfo(object),
        &#34;a_attr&#34;     : {&#34;style&#34;:&#34;font-size:20px&#34;}
    }
    JSONstring = json.dumps(JSONdict)
    return JSONstring</code></pre>
</details>
</dd>
<dt id="general.JsonFromPaths"><code class="name flex">
<span>def <span class="ident">JsonFromPaths</span></span>(<span>dfIndices:Â list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def JsonFromPaths(dfIndices:list[str]):

    fobjects = [ParseFobject(index) for index in dfIndices]

    allJsonStrings = [IndividualJstreeJson(fobject) for fobject in fobjects]

    return allJsonStrings</code></pre>
</details>
</dd>
<dt id="general.ListAllToplevelFiles"><code class="name flex">
<span>def <span class="ident">ListAllToplevelFiles</span></span>(<span>folders:Â list)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Produces a list all files contained in the top level of all folders passed.</p>
<h2 id="args">Args:</h2>
<pre><code>folders : list[Folder]
    #: List of folder objects to find files within (toplevel only)
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>allFiles : list[File] 
    #: List of all file objects contained in all passed folders
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ListAllToplevelFiles(folders:list):
    &#34;&#34;&#34;
        Description:
        ------------
        Produces a list all files contained in the top level of all folders passed.

        
        Args:
        -----    
            folders : list[Folder]
                #: List of folder objects to find files within (toplevel only) 

        Outputs:
        ------------
            allFiles : list[File] 
                #: List of all file objects contained in all passed folders

    &#34;&#34;&#34;

    # Ensure passed list of folders
    folders = [ParseFobject(folder) for folder in folders]
    # List all files in each folder and add to master list
    allFiles = list()
    for folder in folders:
        allFiles.extend(folder.files)
    
    # Return list of file objects
    return allFiles</code></pre>
</details>
</dd>
<dt id="general.ListFolderContents"><code class="name flex">
<span>def <span class="ident">ListFolderContents</span></span>(<span>path, allSubdirs=True, noFiles=False, ignoreProgramFolders=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Produces a list of all filenames and separate list of all subdirectory names within the folder passed.</p>
<h2 id="args">Args:</h2>
<pre><code>path : str
    #: Pathlike string of folder to search within
</code></pre>
<h2 id="kwargs">Kwargs:</h2>
<pre><code>allSubdirs : bool : default=True
    #: Specify whether the list should penetrate into all subdirectories - if false returns toplevel files/subdirs only
noFiles : bool : default=False
    #: If true, output list of subdirectories only
ignoreProgramFolders : bool : default=True
    #: Specify whether to exclude any folders whose name matches those folders specified in the IGNORED_FOLDERS constant
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>filenames : list[str] 
    #: List of all file path strings contained in all relevant folders (dependent on allSubdirs)
allSubfoldersList : list[str]
    #: List of all subfolder path strings (max depth)
subfolderList : list[str]
    #: If allSubdirs=False this returns toplevel subdirs only
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ListFolderContents(path, allSubdirs=True, noFiles=False, ignoreProgramFolders=True):
    &#34;&#34;&#34;
        Description:
        ------------
        Produces a list of all filenames and separate list of all subdirectory names within the folder passed.

        
        Args:
        -----    
            path : str
                #: Pathlike string of folder to search within 

        Kwargs:
        -------
            allSubdirs : bool : default=True
                #: Specify whether the list should penetrate into all subdirectories - if false returns toplevel files/subdirs only
            noFiles : bool : default=False
                #: If true, output list of subdirectories only
            ignoreProgramFolders : bool : default=True
                #: Specify whether to exclude any folders whose name matches those folders specified in the IGNORED_FOLDERS constant 

        Outputs:
        ------------
        
            filenames : list[str] 
                #: List of all file path strings contained in all relevant folders (dependent on allSubdirs)
            allSubfoldersList : list[str]
                #: List of all subfolder path strings (max depth)
            subfolderList : list[str]
                #: If allSubdirs=False this returns toplevel subdirs only

    &#34;&#34;&#34;
    
    
    # Check if valid directory
    path = ParsePath(path)
    if(not validPath(path)):
        return None, None
    
    allSubfoldersList = list()
    filenames = None
    subfolderList = list()
    for (root, subdirs, filenames) in os.walk(path):
        
        # Check if walked into an excluded folder
        rootPath = ParsePath(root)
        for excluded in IGNORED_FOLDERS:
            if(excluded in rootPath.parts):
                continue


        if(not allSubdirs):
            for subdir in subdirs:
                subPath = ParsePath(root) / ParsePath(subdir)
                # Check if this is an ignored program folder
                if(ignoreProgramFolders and subPath.name in IGNORED_FOLDERS):
                    # Skip to next subdir in loop
                    continue
                # Folder safe to include
                subfolderList.extend({subPath})
            # Break after first walk, don&#39;t go down into subdirs
            break 
        
        if(allSubdirs):
            for subdir in subdirs:
                subPath = ParsePath(root) / ParsePath(subdir)
                # Check if this is an ignored program folder
                if(ignoreProgramFolders and subPath.name in IGNORED_FOLDERS):
                    # Skip to next subdir in loop
                    continue
                # Folder safe to include
                allSubfoldersList.extend({subPath})
            # Continue walk into subdirs
            continue

    if(not allSubdirs):
        if(noFiles):
            return subfolderList
        return filenames, subfolderList

    if(allSubdirs):
        return allSubfoldersList</code></pre>
</details>
</dd>
<dt id="general.ListSubdirs"><code class="name flex">
<span>def <span class="ident">ListSubdirs</span></span>(<span>root)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ListSubdirs(root):
    return ListFolderContents(root, allSubdirs=False, noFiles=True)</code></pre>
</details>
</dd>
<dt id="general.ListSubdirsAtDepth"><code class="name flex">
<span>def <span class="ident">ListSubdirsAtDepth</span></span>(<span>root, maxDepth)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Produces a list all subdirectories at the specified depth within the root folder passed.</p>
<h2 id="args">Args:</h2>
<pre><code>root : Pathlike str or Folder object
    #: List of folder objects to find files within (toplevel only) 
maxDepth : int
    #: Furthest depth to penetrate into subdirs - 0 = toplevel, 1 = first subdirs, 2 = subdirs of subdirs etc.
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>allSubdirsList : list[Folder] 
    #: List of all folder objects found within the maxDepth
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ListSubdirsAtDepth(root, maxDepth):
    &#34;&#34;&#34;
        Description:
        ------------
        Produces a list all subdirectories at the specified depth within the root folder passed.

        
        Args:
        -----    
            root : Pathlike str or Folder object
                #: List of folder objects to find files within (toplevel only) 
            maxDepth : int
                #: Furthest depth to penetrate into subdirs - 0 = toplevel, 1 = first subdirs, 2 = subdirs of subdirs etc.

        Outputs:
        ------------
            allSubdirsList : list[Folder] 
                #: List of all folder objects found within the maxDepth

    &#34;&#34;&#34;
    
    rootPath = ParsePath(root)
    
    # Override for returning all subdirs - FIXME - clean up returning paths and folders 
    if(maxDepth == -1):
        return [PATH_DICT[ParsePath(path)] for path in ListFolderContents(root, allSubdirs=True)]

    allSubdirsList = list()
    
    # rootSubdirs = list_subdirs(rootPath)
    
    # if(rootSubdirs != None and len(rootSubdirs)&gt;0):
    #     allSubdirsList.extend(rootSubdirs)
    
    for currRoot, subdirs, files in os.walk(rootPath, topdown=True):
        # Calculate root depth by counting difference in part sizes between root and current path 
        depth =  len(ParsePath(currRoot).parts) - len(ParsePath(root).parts)
        
        if depth &lt; maxDepth:
            # Less than, since listing subdirs of the current depth - any subdir will be one depth further than the current depth
            # e.g. if maxDepth was zero (top level of folder) want no subdirs which would have depth 1.
            # Do nothing if no subdirs
            if(len(subdirs) == 0):
                continue
            # Not yet at maximum depth, parse all subdir paths and add to list
            allFolders = [PATH_DICT[ParsePath(currRoot) / ParsePath(subdir)] for subdir in subdirs]
            allSubdirsList.extend( allFolders )
            if(depth == maxDepth):
                # Don&#39;t recurse any further
                subdirs[:] = []
    
    #print(allSubdirsList)
    return allSubdirsList</code></pre>
</details>
</dd>
<dt id="general.ParseFobject"><code class="name flex">
<span>def <span class="ident">ParseFobject</span></span>(<span>object)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Given either a pathlike string, path, or fobject this returns the associated fobject (using the global PATH_DICT).
If no corresponding object exists this returns None.</p>
<h2 id="args">Args:</h2>
<pre><code>object : str, Path, File or Folder
    #: Accepts any of the above types that may represent the desired fobject
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>output : File, Folder or None 
    #: The file or folder instance returned from the PATH_DICT lookup - if not found returns None
</code></pre>
<h2 id="notes">Notes:</h2>
<p>Possible optimisation could remove this function in places where the object is guaranteed to already be of fobject type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ParseFobject(object):
    &#34;&#34;&#34;
        Description:
        ------------
        Given either a pathlike string, path, or fobject this returns the associated fobject (using the global PATH_DICT).
        If no corresponding object exists this returns None.

        
        Args:
        -----
            object : str, Path, File or Folder
                #: Accepts any of the above types that may represent the desired fobject

        Outputs:
        --------
            output : File, Folder or None 
                #: The file or folder instance returned from the PATH_DICT lookup - if not found returns None

        Notes:    
        ------
        Possible optimisation could remove this function in places where the object is guaranteed to already be of fobject type. 
    &#34;&#34;&#34;
    if(isinstance(object, str)):
        try:
            fobject = PATH_DICT[ParsePath(object)]
            return fobject
        except KeyError:
            print(&#34;Object was not found in dict! - &#34; + str(object))
            return None
    if(isinstance(object, Path)):
        if(object in PATH_DICT):
            fobject = PATH_DICT[object]
            return fobject
        else:
            print(&#34;Path was not found in dict! - &#34; + str(object.as_posix()))
            return None
    if(isinstance(object, File) or isinstance(object, Folder)):
        return object</code></pre>
</details>
</dd>
<dt id="general.ParsePath"><code class="name flex">
<span>def <span class="ident">ParsePath</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Given either a pathlike string, path, or fobject this returns (or generates given a pathlike string) the associated Path object.</p>
<h2 id="args">Args:</h2>
<pre><code>object : str, Path, File or Folder
    #: Accepts any of the above types that may represent the desired path
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>output : Path 
    #: The Path object associated with the passed object
</code></pre>
<h2 id="notes">Notes:</h2>
<p>Possible optimisation could remove this function in places where the object is guaranteed to already be of Path type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ParsePath(path):
    &#34;&#34;&#34;
        Description:
        ------------
        Given either a pathlike string, path, or fobject this returns (or generates given a pathlike string) the associated Path object.

        
        Args:
        -----
            object : str, Path, File or Folder
                #: Accepts any of the above types that may represent the desired path

        Outputs:
        --------
            output : Path 
                #: The Path object associated with the passed object

        Notes:    
        ------
        Possible optimisation could remove this function in places where the object is guaranteed to already be of Path type. 
    &#34;&#34;&#34;
    
    if(isinstance(path, str)):
        path = Path(path)
    elif(isinstance(path, Path)):
        return path
    elif(isinstance(path, File) or isinstance(path, Folder)):
        path = path.path
    elif(isinstance(path, Tree)):
        path = ParsePath(path.rootFolder)
    else: 
        print(&#34;Invalid path type! Type: &#34; + str(type(path)))
        return None
    return path   </code></pre>
</details>
</dd>
<dt id="general.SortItemValueList"><code class="name flex">
<span>def <span class="ident">SortItemValueList</span></span>(<span>itemValueList, desc=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Sort a list of pairs of the form (item, value) based on the value. </p>
<h2 id="args">Args:</h2>
<pre><code>itemValueList : list[tuple]
    #: List of pairs (item, value) to be sorted
</code></pre>
<h2 id="kwargs">Kwargs:</h2>
<pre><code>desc : bool : default=False
    #: If true, sort in descending order
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>sortedItemsList : list[tuple] 
    #: The sorted list of (item, value) pairs
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SortItemValueList(itemValueList, desc=False):
    &#34;&#34;&#34;
        Description:
        ------------
        Sort a list of pairs of the form (item, value) based on the value. 

        
        Args:
        -----
            itemValueList : list[tuple]
                #: List of pairs (item, value) to be sorted

        Kwargs:
        -------
            desc : bool : default=False
                #: If true, sort in descending order
        
        Outputs:
        --------
            sortedItemsList : list[tuple] 
                #: The sorted list of (item, value) pairs
    &#34;&#34;&#34;
    values = [itemValue[1] for itemValue in itemValueList]
    indices = np.argsort(values)
    if(desc):
        indices = np.flip(indices)
    sortedItemsList = list()
    for idx in indices:
        sortedItemsList.append(itemValueList[idx][0])
    return sortedItemsList</code></pre>
</details>
</dd>
<dt id="general.WriteStorageInfo"><code class="name flex">
<span>def <span class="ident">WriteStorageInfo</span></span>(<span>object)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Given a fobject this writes the string with top and net size information. Uses size from hurry.filesize to convert to readable size</p>
<h2 id="args">Args:</h2>
<pre><code>object : File or Folder
    #: File or Folder object (sizes stored in top and net size attributes)
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>info : str 
    #: The string with size information
</code></pre>
<h2 id="notes">Notes:</h2>
<p>File size is stored in an attribute called "netSize" to match the netSize attribute of folders - to allow methods to reference this property that allow both file and folder object inputs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WriteStorageInfo(object):
    &#34;&#34;&#34;
        Description:
        ------------
        Given a fobject this writes the string with top and net size information. Uses size from hurry.filesize to convert to readable size

        
        Args:
        -----
            object : File or Folder
                #: File or Folder object (sizes stored in top and net size attributes)

        Outputs:
        --------
            info : str 
                #: The string with size information

        Notes:    
        ------
        File size is stored in an attribute called &#34;netSize&#34; to match the netSize attribute of folders - to allow methods to reference this property that allow both file and folder object inputs 
    &#34;&#34;&#34;

    path = ParsePath(object)
    object = PATH_DICT[path]
    # Only write netSize (filesize) if file
    if(isinstance(object, File)):
        info = &#34; #: (&#34; + str(size(object.netSize)) + &#34;)&#34;
    # Write top and net sizes for folder
    if(isinstance(object, Folder)):
        info = &#34; #: (Top: &#34; + str(size(object.topSize)) + &#34;, Net: &#34; + str(size(object.netSize)) + &#34;)&#34;
    return info</code></pre>
</details>
</dd>
<dt id="general.calculate_storage"><code class="name flex">
<span>def <span class="ident">calculate_storage</span></span>(<span>self:Â <a title="general.Folder" href="#general.Folder">Folder</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_storage(self:Folder):
    self.topSize = 0
    self.netSize = 0
    # File contribution to size
    for file in self.files:
        try:
            self.topSize += file.netSize
            #print(&#34;File was ok&#34;)
        except AttributeError:
            print(&#34;File had no attributes set!&#34; + str(file) )
    
    self.netSize = self.topSize
    # Subdir contribution to net size
    if(len(self.subdirs) != 0):
        for subdir in self.subdirs:
            self.netSize += subdir.netSize</code></pre>
</details>
</dd>
<dt id="general.makeNewConsecutiveFolder"><code class="name flex">
<span>def <span class="ident">makeNewConsecutiveFolder</span></span>(<span>root, folderName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Make a new folder within the specified root with consecutively increasing numbering of the form folderName_#</p>
<h2 id="args">Args:</h2>
<pre><code>root : pathlike object or fobject
    #: Folder to create new folders within
folderName : str
    #: Name of the new folders to create, eg 'run' would create folders run_1, run_2 etc
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>#: Path to newly created folder
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeNewConsecutiveFolder(root, folderName):
    &#34;&#34;&#34;
        Description:
        ------------
        Make a new folder within the specified root with consecutively increasing numbering of the form folderName_#

        
        Args:
        -----
            root : pathlike object or fobject
                #: Folder to create new folders within
            folderName : str
                #: Name of the new folders to create, eg &#39;run&#39; would create folders run_1, run_2 etc
        
        
        Outputs:
        --------
            #: Path to newly created folder
            
    &#34;&#34;&#34; 
    
    root = ParsePath(root)
    # Make root directory if not already exist
    os.makedirs(root, exist_ok=True)
        
        # Ensure folder name ends with underscore _
    name = str(folderName)
    if(name[len(name)-1] != &#34;_&#34;):
       name = name + r&#34;_&#34;
        
        # Test for already created folders with correct name
    n=1
    test_dir = root / (name + str(n))
    while (os.path.exists(test_dir)):
        n += 1
        test_dir = root / (name + str(n))
        # Create new folder with _n
    os.makedirs(test_dir)
        
    return Path(test_dir)</code></pre>
</details>
</dd>
<dt id="general.parseCSVstring"><code class="name flex">
<span>def <span class="ident">parseCSVstring</span></span>(<span>csvString:Â str)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Parse a comma separated value string into a list of values.</p>
<h2 id="args">Args:</h2>
<pre><code>csvString : str
    #: String containing comma separated values
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>splitList : list[str]
    #: List of values
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parseCSVstring(csvString:str):
    &#34;&#34;&#34;
        Description:
        ------------
        Parse a comma separated value string into a list of values.

        
        Args:
        -----
            csvString : str
                #: String containing comma separated values
                    
        Outputs:
        --------
            splitList : list[str]
                #: List of values
            
    &#34;&#34;&#34;     
    splitList = [split.strip() for split in csvString.split(&#34;,&#34;) if split != &#39;&#39;]
    if(len(splitList) == 0):
        return None
    if(len(splitList) == 1 and splitList[0] == &#39;&#39;):
        return None
    return splitList</code></pre>
</details>
</dd>
<dt id="general.sortbySizeDesc"><code class="name flex">
<span>def <span class="ident">sortbySizeDesc</span></span>(<span>unsortedObjects:Â list, topLevel=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Sort a list of fobjects in descending size order. Kwarg topLevel only relevant for folders (sort by topLevel as opposed to netSize).</p>
<h2 id="args">Args:</h2>
<pre><code>unsortedObjects : list[File or Folder]
    #: List of fobjects to be sorted
</code></pre>
<h2 id="kwargs">Kwargs:</h2>
<pre><code>topLevel : bool : default=False
    #: If true and fobjects are Folders, sort by topLevel not netSizes
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>sortedList : list[File or Folder] 
    #: The sorted (descending order) list of files
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sortbySizeDesc(unsortedObjects:list, topLevel=False):
    &#34;&#34;&#34;
        Description:
        ------------
        Sort a list of fobjects in descending size order. Kwarg topLevel only relevant for folders (sort by topLevel as opposed to netSize).

        
        Args:
        -----
            unsortedObjects : list[File or Folder]
                #: List of fobjects to be sorted

        Kwargs:
        -------
            topLevel : bool : default=False
                #: If true and fobjects are Folders, sort by topLevel not netSizes
        
        Outputs:
        --------
            sortedList : list[File or Folder] 
                #: The sorted (descending order) list of files
    &#34;&#34;&#34;
    if(len(unsortedObjects) == 0):
        return unsortedObjects
    sizes = []
    sortedList = list()
    for object in unsortedObjects:
        # Ensure toplevel = False if object is a file 
        if(isinstance(object, File)):
            topLevel = False
        # Record net or toplevel size
        if(not topLevel):
            sizes.extend({object.netSize}) # netSize = filesize if object is file
        if(topLevel):
            sizes.extend({object.topSize}) # sort by toplevel size only (objects must be folders)
    # Sort by descending size
    sortedArgs = np.flip(np.argsort(sizes))
    for i in range(len(sizes)):
        sortedList.append(unsortedObjects[sortedArgs[i]])
    return sortedList</code></pre>
</details>
</dd>
<dt id="general.validPath"><code class="name flex">
<span>def <span class="ident">validPath</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description:</h2>
<p>Checks whether the given path is valid (exists on the filesystem)</p>
<h2 id="args">Args:</h2>
<pre><code>path : pathlike object
    #: Uses ParsePath to convert any pathlike input to the underlying Path
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>output : bool 
    #: True if the path exists on the filesystem
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validPath(path):
    &#34;&#34;&#34;
        Description:
        ------------
        Checks whether the given path is valid (exists on the filesystem)

        
        Args:
        -----
            path : pathlike object
                #: Uses ParsePath to convert any pathlike input to the underlying Path

        Outputs:
        --------
            output : bool 
                #: True if the path exists on the filesystem
        
    &#34;&#34;&#34;

    path = ParsePath(path)
    if(not os.path.exists(path)):
        print(&#34;Invalid directory - &#34; + str(path))
        return False
    return True</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="general.Config"><code class="flex name class">
<span>class <span class="ident">Config</span></span>
<span>(</span><span>sizeThreshold=0, depth=-1, included=None, excluded=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="class">Class:</h2>
<p>Class that stores the configuration of the duplicate search.
Contains preset size (1000 bytes) for the size clustering threshold.</p>
<h2 id="description">Description:</h2>
<p>Constructor for the Config class. Takes no input, kwargs specify default settings and included/excluded folders if specified.</p>
<h2 id="inputs">Inputs:</h2>
<h2 id="kwargs">Kwargs:</h2>
<pre><code>sizeThreshold : int : default=0
    #: Threshold (bytes) below which to ignore files
depth : int : default=-1
    #: Specifies the search depth (-1 = all)
included : list[path]
    #: List of paths to include (only those listed are used)
excluded : list[path]
    #: List of paths to exclude
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Config():
    &#34;&#34;&#34;
        Class:
        ------------
        Class that stores the configuration of the duplicate search. 
        Contains preset size (1000 bytes) for the size clustering threshold.

    &#34;&#34;&#34;
    def __init__(self, sizeThreshold=0, depth=-1, included=None, excluded=None):
        &#34;&#34;&#34;
            Description:
            ------------
            Constructor for the Config class. Takes no input, kwargs specify default settings and included/excluded folders if specified.

            Inputs:
            -------
            Kwargs:
            -------
                sizeThreshold : int : default=0
                    #: Threshold (bytes) below which to ignore files
                depth : int : default=-1
                    #: Specifies the search depth (-1 = all)
                included : list[path]
                    #: List of paths to include (only those listed are used)
                excluded : list[path]
                    #: List of paths to exclude
        &#34;&#34;&#34;
    # -------- Default settings -------- #
        # All paths to include (if not whole tree)
        if(included != None):
            self.includedPaths = [ParsePath(inc) for inc in included]
        else:
            self.includedPaths = list()
        # Stored trees
        self.trees = list() 
        # Folders to exclude (absolute paths)
        self.excludedPaths = list()
        if(excluded != None):
            # Ensure blank strings are omitted
            for exc in excluded:
                if(exc != &#39;&#39;):
                    self.excludedPaths.append(ParsePath(exc))
        
        # Folder to hold this search run and append file (set after construct)
        self.runPath = None
        self.appendFile = None
        # Size threshold (files below this will be ignored)
        self.sizeThreshold = sizeThreshold
        # Cluster threshold when clustering files by size (bytes)
        self.clusterThreshold = 1000
        # Extensions to ignore 
        self.excludedExt = list()
        # Search depth (-1 = everything, 0 = current folder only, 1 = folder + subfolders only, etc)
        self.depth = depth
        # Dupe log associated with this config
        self.log = Log()
        # Set config on dupeLog
        self.log.config = self
        # Master path dict (set after construct)
        self.pathDict = None
        # Similarity threshold (default at 100%)
        self.similarityThreshold = 1 </code></pre>
</details>
</dd>
<dt id="general.File"><code class="flex name class">
<span>class <span class="ident">File</span></span>
<span>(</span><span>path, tree=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="class">Class:</h2>
<p>Class that represents an individual file and holds various attributes derived from the path. netSize is the file size.
If the file cannot be accessed (FileNotFoundError exception) this is logged in the tree object.</p>
<h2 id="description">Description:</h2>
<p>Constructor for the File class. Takes the file pathlike object as input.</p>
<h2 id="inputs">Inputs:</h2>
<h2 id="args">Args:</h2>
<pre><code>path : pathlike object
    #: The pathlike object of the file path
</code></pre>
<h2 id="kwargs">Kwargs:</h2>
<pre><code>tree : Tree : default=None
    #: Reference to the tree this file is within
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class File():
    &#34;&#34;&#34;
        Class:
        ------------
        Class that represents an individual file and holds various attributes derived from the path. netSize is the file size.
        If the file cannot be accessed (FileNotFoundError exception) this is logged in the tree object.
    &#34;&#34;&#34;
    
    def __init__(self, path, tree=None):
        &#34;&#34;&#34;
            Description:
            ------------
            Constructor for the File class. Takes the file pathlike object as input.
            
                        
            Inputs:
            -------
            Args:
            -----
                path : pathlike object
                    #: The pathlike object of the file path
            
            Kwargs:
            -------
                tree : Tree : default=None
                    #: Reference to the tree this file is within
                
            
        &#34;&#34;&#34;
        
        #print(&#34;constructed file: &#34; + str(parsePath(path)))
        global PATH_DICT
        # Filepath
        self.path = ParsePath(path)
        # Path string (for dataframe)
        self.pathStr = self.path.as_posix()
        # Add to path dict
        PATH_DICT[self.path] = self
        # Master tree this file belongs to (if specified)
        if(tree):
            self.tree = tree
        # Filename
        self.name = self.path.stem
        # Parent folder
        self.parent = self.path.parent.as_posix()
        # Extension
        self.extension = self.path.suffix
        # Fingerprint string
        self.fingerprint = None
        # File size #: called netSize for cross compatibility (in generic file/folder methods asking for size netSize = filesize for a file)
        try:
            self.netSize = self.path.stat().st_size
        except FileNotFoundError:
            print(&#34;The file could not be accessed! #: &#34; + self.path.absolute().as_posix())
            # Remove this file from the dict before continuing 
            del PATH_DICT[self.path]
            if(tree):
                tree.fileExceptions.append(self)
            return None

        # Calculate the required JSON string for jsTree
        self.jstreeJson = IndividualJstreeJson(self)


        # ---------- TAGS ---------- #
        # List of all tags associated to this file
        self.tags = list()
        # Basic type tag determined from the extension (also stored in the tags list but has separate reference for easy access)
        self.extensionSubtypeStr = tag.TagByExtensionSubtype(self).tagName

    # String representation (for easy debugging - replaces unreadable memory addresses)
    def __repr__(self):
        return &#34;&lt;File: .../&#34; + self.path.parent.as_posix() +&#34;/&#34; + self.path.name +&#34;&gt;&#34;</code></pre>
</details>
</dd>
<dt id="general.Folder"><code class="flex name class">
<span>class <span class="ident">Folder</span></span>
<span>(</span><span>path, makeAllSubdirs=True, isTree=False, tree=None, ignoreProgramFolders=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="class">Class:</h2>
<p>Class that represents an individual folder. Contains references to all subfolder objects and the files within this folder.</p>
<h2 id="description">Description:</h2>
<p>Constructor for the Folder class. Takes the folder pathlike object as input.
Constructing the folder recursively builds all subfolders and file objects.</p>
<h2 id="inputs">Inputs:</h2>
<h2 id="args">Args:</h2>
<pre><code>path : pathlike object
    #: The pathlike object of the folder path
</code></pre>
<h2 id="kwargs">Kwargs:</h2>
<pre><code>makeAllSubdirs : bool : default=True
    #: If true, recursively construct all subdirectories
isTree : bool : default=False
    #: Signifies if this folder is also a tree root
tree : Tree : default=None
    #: Reference to the tree this folder is within
ignoreProgramFolders : bool : default=True
    #: If true, exclude folders whose name matches those in the EXCLUDED_FOLDERS constant
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Folder():
    &#34;&#34;&#34;
        Class:
        ------------
        Class that represents an individual folder. Contains references to all subfolder objects and the files within this folder.
    &#34;&#34;&#34;
    def __init__(self, path, makeAllSubdirs=True, isTree=False, tree=None, ignoreProgramFolders=True):
        &#34;&#34;&#34;
            Description:
            ------------
            Constructor for the Folder class. Takes the folder pathlike object as input.
            Constructing the folder recursively builds all subfolders and file objects.
                        
            Inputs:
            -------
            Args:
            -----
                path : pathlike object
                    #: The pathlike object of the folder path
            
            Kwargs:
            -------
                makeAllSubdirs : bool : default=True
                    #: If true, recursively construct all subdirectories
                isTree : bool : default=False
                    #: Signifies if this folder is also a tree root
                tree : Tree : default=None
                    #: Reference to the tree this folder is within
                ignoreProgramFolders : bool : default=True
                    #: If true, exclude folders whose name matches those in the EXCLUDED_FOLDERS constant
            
        &#34;&#34;&#34;
        # For modifying the pathDict
        global PATH_DICT
        # Folder path
        self.path = ParsePath(path)
        # Path string (for dataframe)
        self.pathStr = self.path.as_posix()
        # Name
        self.name = self.path.stem
        # Parent folder
        self.parent = self.path.parent.as_posix()
        # Master tree this folder belongs to
        self.tree = tree
        # Add to path dict
        PATH_DICT[self.path] = self
        # Use to signify if this folder represents an entire tree
        self.isTree = isTree

        self.files = list()
        self.subdirs = list()
        
        # Add all files in folder to list 
        _files, _subdirs = ListFolderContents(path, allSubdirs=False, ignoreProgramFolders=ignoreProgramFolders)
        # Must first check if not None - since len(None) gives error
        if(_files != None and len(_files) != 0):
            for f in _files:
                filePath = Path(self.path / Path(f))
                file = File(filePath, tree=self.tree)
                # File will have no netsize if exception thrown when constructing - do not include in file list
                try:
                    _test = file.netSize
                    self.files.append(file)
                except AttributeError:
                    print(&#34;File has no net size, ignoring&#34;)
                    continue
        if(_subdirs != None and len(_subdirs) != 0):
            if(makeAllSubdirs):
                # Create all subfolders (recursively call Folder constructor on subdirs)
                for sdir in _subdirs:
                    sdirPath = Path(self.path / Path(sdir))
                    subdir = Folder(sdirPath, makeAllSubdirs=True, tree=self.tree)
                    self.subdirs.append(subdir)
        
        # Calculate net and top sizes of this folder
        calculate_storage(self)
        
        # Sort the list of files in descending order (optional, but useful later)
        self.files = sortbySizeDesc(self.files)

        # Create the JSON string for this jsTree node
        self.jstreeJson = IndividualJstreeJson(self)

        # Tags for this folder
        self.tags = list()

        

    # String representation (for easy debugging - replaces unreadable memory addresses)
    def __repr__(self):
        return &#34;&lt;Folder: .../&#34; + self.path.name +&#34;&gt;&#34;</code></pre>
</details>
</dd>
<dt id="general.Log"><code class="flex name class">
<span>class <span class="ident">Log</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="class">Class:</h2>
<p>Class that stores the results of a single duplicate finding run.
Contains lists of duplicate fingerprints, and dicts that store scores of similar folders.</p>
<h2 id="description">Description:</h2>
<p>Constructor for the Log class. Takes no input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Log():
    &#34;&#34;&#34;
        Class:
        ------------
        Class that stores the results of a single duplicate finding run. 
        Contains lists of duplicate fingerprints, and dicts that store scores of similar folders.
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
            Description:
            ------------
            Constructor for the Log class. Takes no input
        &#34;&#34;&#34;
        # Configuration object associated with this log 
        self.config = None
        
        self.startTime = time.time()
        self.elapsedTime = 0

        # List of folders scanned
        self.scannedFolders = list()
        # Dict of file fingerprint -&gt; file(s) (list of file(s) with that fingerprint)
        self.FpFilesDict = dict()
        # List of all fingerprints to check
        self.FpList = list()
        # List of duplicated fingerprints (to be calculated)
        self.dupeFpList = list()
        # List of individual fingerprint logs
        self.dupeFpLogList = list()
        # Dict containing all folder pairs -&gt; similarity scores (to avoid double counting)
        self.similarPairScoresDict = dict()
        # Dict containing base folder pair -&gt; recursive parent pairs
        self.allPairRecursiveScores = dict()
        # Total duplicate storage scanned
        self.totDupeStorage = 0
        # Total storage scanned
        self.totScannedStorage = 0
        # Tot files ignored (below threshold)
        self.filesIgnored = 0</code></pre>
</details>
</dd>
<dt id="general.Tree"><code class="flex name class">
<span>class <span class="ident">Tree</span></span>
<span>(</span><span>root, ignoreProgramFolders=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="class">Class:</h2>
<p>Class that represents the entire file system tree. Contains a reference to the tree root folder (that recursively contains all subfolder and file objects)
Contains the file and folder dataframes that represent the entire file system</p>
<h2 id="description">Description:</h2>
<p>Constructor for the Tree class. Takes the tree root pathlike object as input.
Constructing the tree root folder recursively builds the tree with all subfolders and files
Builds the file and folder dataframes once the file/folders are built</p>
<h2 id="inputs">Inputs:</h2>
<h2 id="args">Args:</h2>
<pre><code>root : pathlike object
    #: The pathlike object of the tree root folder
</code></pre>
<h2 id="kwargs">Kwargs:</h2>
<pre><code>ignoreProgramFolders : bool : default=True
    #: If true, exclude folders whose name matches those in the EXCLUDED_FOLDERS constant
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tree():
    &#34;&#34;&#34;
        Class:
        ------------
        Class that represents the entire file system tree. Contains a reference to the tree root folder (that recursively contains all subfolder and file objects)
        Contains the file and folder dataframes that represent the entire file system
    &#34;&#34;&#34;
    
    
    def __init__(self, root, ignoreProgramFolders=True):
        &#34;&#34;&#34;
            Description:
            ------------
            Constructor for the Tree class. Takes the tree root pathlike object as input.
            Constructing the tree root folder recursively builds the tree with all subfolders and files
            Builds the file and folder dataframes once the file/folders are built
            
            Inputs:
            -------
            Args:
            -----
                root : pathlike object
                    #: The pathlike object of the tree root folder
            
            Kwargs:
            -------
                ignoreProgramFolders : bool : default=True
                    #: If true, exclude folders whose name matches those in the EXCLUDED_FOLDERS constant
            
        &#34;&#34;&#34;
        
        startTime = time.time()
        self.rootPath = ParsePath(root)
        
        global PATH_DICT
        # Clear the dict to avoid issues when constructing higher level tree after a subtree was constructed (subtree root would already be in dict and so the new tree would simply return the subtree as the root folder)
        PATH_DICT.clear()

        # Clear any previous fobject associations in the tag tree
        tag.ClearPreviousTags()

        # List of files that threw exceptions when reading size 
        self.fileExceptions = list()

        # Recursively build all the folders starting from this root         
        self.rootFolder = Folder(self.rootPath, makeAllSubdirs=True, isTree=True, tree=self, ignoreProgramFolders=ignoreProgramFolders)

        # Build the file and folder dataframes 
        self.folderDf = None
        self.fileDf = None
        BuildDataframes(self)
        self.buildTime = (time.time()-startTime)/60
        print(&#34;Tree built in &#34; + f&#34;{self.buildTime:2.2f}&#34; + &#34;minutes&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fileorganiser" href="index.html">fileorganiser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="general.AllJstreeJson" href="#general.AllJstreeJson">AllJstreeJson</a></code></li>
<li><code><a title="general.BuildDataframes" href="#general.BuildDataframes">BuildDataframes</a></code></li>
<li><code><a title="general.IndividualJstreeJson" href="#general.IndividualJstreeJson">IndividualJstreeJson</a></code></li>
<li><code><a title="general.JsonFromPaths" href="#general.JsonFromPaths">JsonFromPaths</a></code></li>
<li><code><a title="general.ListAllToplevelFiles" href="#general.ListAllToplevelFiles">ListAllToplevelFiles</a></code></li>
<li><code><a title="general.ListFolderContents" href="#general.ListFolderContents">ListFolderContents</a></code></li>
<li><code><a title="general.ListSubdirs" href="#general.ListSubdirs">ListSubdirs</a></code></li>
<li><code><a title="general.ListSubdirsAtDepth" href="#general.ListSubdirsAtDepth">ListSubdirsAtDepth</a></code></li>
<li><code><a title="general.ParseFobject" href="#general.ParseFobject">ParseFobject</a></code></li>
<li><code><a title="general.ParsePath" href="#general.ParsePath">ParsePath</a></code></li>
<li><code><a title="general.SortItemValueList" href="#general.SortItemValueList">SortItemValueList</a></code></li>
<li><code><a title="general.WriteStorageInfo" href="#general.WriteStorageInfo">WriteStorageInfo</a></code></li>
<li><code><a title="general.calculate_storage" href="#general.calculate_storage">calculate_storage</a></code></li>
<li><code><a title="general.makeNewConsecutiveFolder" href="#general.makeNewConsecutiveFolder">makeNewConsecutiveFolder</a></code></li>
<li><code><a title="general.parseCSVstring" href="#general.parseCSVstring">parseCSVstring</a></code></li>
<li><code><a title="general.sortbySizeDesc" href="#general.sortbySizeDesc">sortbySizeDesc</a></code></li>
<li><code><a title="general.validPath" href="#general.validPath">validPath</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="general.Config" href="#general.Config">Config</a></code></h4>
</li>
<li>
<h4><code><a title="general.File" href="#general.File">File</a></code></h4>
</li>
<li>
<h4><code><a title="general.Folder" href="#general.Folder">Folder</a></code></h4>
</li>
<li>
<h4><code><a title="general.Log" href="#general.Log">Log</a></code></h4>
</li>
<li>
<h4><code><a title="general.Tree" href="#general.Tree">Tree</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>