<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tagging API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tagging</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from bokeh.models.ranges import FactorRange
from numpy import nan
import pandas as pd
from matplotlib import pyplot as plt
from pathlib import Path
from collections import defaultdict
from hurry.filesize import size, alternative
from math import ceil, floor, log10, pow

# Bokeh plotting
from bokeh.plotting import figure 
from bokeh.layouts import column
from bokeh.models import ColumnDataSource, HoverTool
from bokeh.resources import CDN
from bokeh.embed import components
from bokeh.io import show

# NLTK

from nltk.corpus import wordnet as wn, stopwords
from nltk.stem import PorterStemmer, WordNetLemmatizer
from nltk.tokenize import word_tokenize



# Local imports
from src.fileorganiser.globals import *

import src.fileorganiser.general as gen

lem = WordNetLemmatizer()
stem = PorterStemmer()
#stopWords = set(stopwords.words(&#34;english&#34;))

# The tag object associated to a SINGLE fobject (with the associated score)
class Tag():
    &#39;&#39;&#39;
    Class:
    ------
    Defines a single Tag object, contains a reference to the parent and child tags of this tag (if appropriate).

    Each tag also contains a list of all the files/folders with this particular tag.
    
    &#39;&#39;&#39;
    
    def __init__(self, tagName, parent=None, tagTree=None):
        &#39;&#39;&#39; 
        Description
        -----------
        Constructor for the Tag object, tag is constructed using the tag name and a reference to its parent tag (if any).

        If a tag tree is specified, this constructor will update the tagTree.allTagsList and tagTree.allTagsNameDict attributes on the tree.

        Args:
        -----
            tagName : str
                #: The name of this tag
        Kwargs:
        -------
            parent : Tag : default=None
                #: The parent of this tag (if any)
            tagTree : TagTree : default=None
                #: The tag tree this tag belongs to (if any)
        
        &#39;&#39;&#39;
        
        # Add to tag tree
        if(tagTree):
            tagTree.allTagsList.append(self)
            tagTree.allTagsNameDict[tagName] = self
        
        # Tag name
        self.tagName = tagName
        # Parent tag in heirachy (if defined)
        self.parentTag = parent
        # If parent was set, add this tag to the child tags of the parent
        if(parent):
            parent.childTags.append(self)
        # Child tags
        self.childTags = list()
        # TagTree depth (depth from tagtree root)
        self.tagDepth = 1
        
        

        # Files with this tag
        self.files = list()
        # Folders with this tag
        self.folders = list()



# Function to tag a fobject (uses a tag name string to reference the tag)
def TagFobject(fobject, tagName):
    &#39;&#39;&#39; 
        Description
        -----------
        Assign the specified tag (referenced by tag name) to the given fobject.

        Assigning a tag that has parents will recursively add this fobject to the parent tags list of fobjects.

        Args:
        -----
            fobject : File or Folder
                #: The fobject to tag
            tagName : str
                #: The name of the tag to assign
       
    &#39;&#39;&#39;
    # Get the appropriate tag object if passed string
    if(isinstance(tagName, str)):
        try:
            tagName = TAG_TREE.allTagsNameDict[tagName]
        except KeyError:
            print(&#34;No such existing tag! #: Creating new parentless tag with name: &#34; + tagName)
            tagName = Tag(tagName)

    # Add this tag to the fobject list of tags
    fobject.tags.append(tagName)
    
    # Add this fobject to the appropriate list of tagged files/folders
    if(isinstance(fobject, gen.File)):
        tagName.files.append(fobject)
    else:
        tagName.folders.append(fobject)
    
    # Add this fobject to the parent tag list (recursively)
    AddFobjectToParents(fobject, tagName)


# Add the fobject to the parent tag fobject list (recursively)
def AddFobjectToParents(fobject, tag):
    &#39;&#39;&#39; 
    Description
    -----------
    Recursively add this fobject to this tags parent tags list of fobjects.

    Args:
    -----
        fobject : File or Folder
            #: The fobject to tag
        tag : Tag
            #: The starting tag whose parents should be added to 
    
    &#39;&#39;&#39;
    if(tag.parentTag):
        # Add this fobject to the appropriate list of tagged files/folders
        if(isinstance(fobject, gen.File)):
            tag.parentTag.files.append(fobject)
        else:
            tag.parentTag.folders.append(fobject)
        # Recurse until no parent tags left
        AddFobjectToParents(fobject, tag.parentTag)


# When building a new tree, must clear all tag associations with fobjects 
def ClearPreviousTags():
    &#39;&#39;&#39; 
    Description
    -----------
    Clears the tag tree
    &#39;&#39;&#39;
    if(TAG_TREE):
        for tag in TAG_TREE.allTagsList:
            tag.files.clear()
            tag.folders.clear()



# Used to extract the extension keywords from the data file (list of extensions and descriptions)
def BuildExtensionTypeData(tagTree):
    &#39;&#39;&#39; 
    Description
    -----------
    Read the data files located in the src/data folder used to define the extension type/subtype tags. 
    
    Args:
    -----
        tagTree : TagTree
            #: The tag tree to store tag data within
    
    &#39;&#39;&#39;
    # Read the type -&gt; subtypes definitions
    subtypeDefinitions = pd.read_excel(Path(&#34;.&#34;) / &#34;src/fileorganiser/data/ExtensionTypeSubtypesDefinitions.xls&#34;)

    # Read the extension types defined (column names)
    extTypes = list(subtypeDefinitions.columns)
    # Map each subtype to its parent type and vice versa
    
    for type in extTypes:
        # Iterate the list of subtypes for this type
        for subtype in subtypeDefinitions[type]:
            # Skip nan entries 
            if(str(subtype) == &#34;nan&#34;):
                continue
            else:
                # Set types that have no subtype to have subtype=type
                if(subtype == &#34;None&#34;):
                    tagTree.subtypeTypeDict[type] = type
                    tagTree.typeSubtypeDict[type].append(type)
                else:
                    tagTree.subtypeTypeDict[subtype] = type
                    tagTree.typeSubtypeDict[type].append(subtype)

    
    # Build all extension type tag objects
    CreateExtensionTypeTags(tagTree)
    # Associate extensions with the subtype tags
    AssociateExtensionTypeTags(tagTree)


# Read the extension -&gt; type data and create appropriate dicts 
def AssociateExtensionTypeTags(tagTree):
    &#39;&#39;&#39; 
    Description
    -----------
    Read the data files located in the src/data folder used to define the extension type/subtype tags. 

    This method associates each extension type/subtype with the corresponding tag object (stored in the tagTree accross several dicts that map type &lt;-&gt; tag and subtype &lt;-&gt; tag). 

    Args:
    -----
        tagTree : TagTree
            #: The tag tree to store tag data within
    
    &#39;&#39;&#39;   
    # Read the extension -&gt; subtype data from the excel file
    extensionTypeDf = pd.read_excel(Path(&#34;.&#34;) / &#34;src/fileorganiser/data/ExtensionSubtypeLabels.xls&#34;)
    
    # Dict for extension -&gt; type tag
    tagTree.extensionSubtypeDict = dict()
    # Dict for type tag -&gt; corresponding extension(s)
    tagTree.subtypeExtensionsDict = defaultdict(list)

    for row in extensionTypeDf.iterrows():
        ext = row[1][&#34;Extension&#34;]
        try:
            # Associate this extension with a (sub)type tag (type names in data spreadsheet must match tag type names!)
            tagTree.extensionSubtypeDict[ext] = tagTree.allTagsNameDict[row[1][&#34;SubType&#34;]]
        except KeyError:
            # Catch exception for bad type name data from spreadsheet (eg nan entries)
            print(&#34;Type name has no corresponding tag object! Type name: &#34; + str(row[1][&#34;SubType&#34;]) + &#34; #: Setting type as misc. &#34;)
            tagTree.extensionSubtypeDict[row[1][&#34;Extension&#34;]] = tagTree.allTagsNameDict[&#39;Misc&#39;]
        
        tagTree.subtypeExtensionsDict[row[1][&#34;SubType&#34;]].append(ext)
  


# Build the tag objects for each extension type and subtypes
def CreateExtensionTypeTags(tagTree):
    &#39;&#39;&#39; 
    Description
    -----------
    Read the data files located in the src/data folder used to define the extension type/subtype tags. 

    This method constructs the tag instance for each extension type/subtype
    Args:
    -----
        tagTree : TagTree
            #: The tag tree to store tag data within
    
    &#39;&#39;&#39;   
    # Extension type tag (all extensionTypes will be children of this tag)
    extensionTypeTag = Tag(&#39;Extension Type&#39;, tagTree=tagTree)
    
    # Create all extension type.subtype tags
    for extType in list(tagTree.typeSubtypeDict.keys()):
        # Create the tag object for this extension type
        tag = Tag(extType, parent=extensionTypeTag, tagTree=tagTree)
        # Create the subtype tags
        for subType in tagTree.typeSubtypeDict[extType]:
            subTag = Tag(subType, parent=tag, tagTree=tagTree)


# Class that contains all the tag keywords and tag heirachy
class TagTree():
    &#39;&#39;&#39;
    Class:
    ------
    This class stores the hierachical relationship between tags in a parent/child structure.

    This class also stores the definitions for the extension type &lt;-&gt; tag and subtype &lt;-&gt; tag read from the data files in the src/data folder.

    &#39;&#39;&#39;
    def __init__(self):
        # List of all tags 
        self.allTagsList = list()
        # Dict to access tags by name (name str -&gt; tag)
        self.allTagsNameDict = dict()
        
        # Dicts of type -&gt; subtype and vice versa
        self.subtypeTypeDict = dict()
        self.typeSubtypeDict = defaultdict(list)
        # Dict for extension -&gt; subtype tag and vice versa
        self.extensionSubtypeDict = dict()
        self.subtypeExtensionsDict = defaultdict(list)
        
        # Function that builds the previously defined dicts
        BuildExtensionTypeData(self)
               
        # Dict of keywords -&gt; tag
        self.keywordsTagDict = dict()

# Global tag tree      
TAG_TREE = TagTree() 

   

## Associate a tag to this file based on it&#39;s extension type
def TagByExtensionSubtype(file):
    &#39;&#39;&#39; 
    Description
    -----------
    Using the definitions defined in the TAG_TREE, tag a given file based on its extension (subtype).
    
    Args:
    -----
        file : File
            #: The file to be tagged
    
    &#39;&#39;&#39;   
    extension = ParseExtension(file)

    try:
        # Set the extension type attribute
        extensionTypeTag = TAG_TREE.extensionSubtypeDict[extension]
        # Tag the file with this extension type tag
        TagFobject(file, TAG_TREE.extensionSubtypeDict[extension].tagName)
    except KeyError:
        #print(&#34;Extension has no associated type! Ext: &#34; + str(extension))
        # Give the unknown extension type the misc tag
        extensionTypeTag = TAG_TREE.allTagsNameDict[&#39;Misc&#39;]
        TagFobject(file, &#39;Misc&#39;)
        # Log this uncategorised extension to the typeExtensionsDict
        if(extension not in TAG_TREE.subtypeExtensionsDict[&#39;Misc&#39;]):
            TAG_TREE.subtypeExtensionsDict[&#39;Misc&#39;].append(extension)
    return extensionTypeTag


# Sum the total storage for this type tag
def GetStorageForType(typeTag:Tag):
    totalSize = 0
    for file in typeTag.files:
        totalSize += file.netSize
    return totalSize


# Build a histogram for extension tag type frequency 
def GetTypeFrequencies(hideEmpty=True, prunedFileDf=None):
    &#39;&#39;&#39; 
    Description
    -----------
    Get the number of file of each extension type for constructing the distribution histograms, and the storage occupied by the files of each type.
    
    Kwargs:
    -------
        hideEmpty : bool : default=True
            #: Do not include types with zero files
        prunedFileDf : pd.Dataframe : default=None
            #: Used if the tree has been pruned to update the distributions for the pruned tree
    
    Outputs:
    -------
        typeNumber : dict[str] = int
            #: dict with type (tagName) -&gt; number of files
        typeStorage : dict[str] = int
            #: dict with type (tagName) -&gt; storage occupied

    &#39;&#39;&#39; 
    typeNumber = dict()
    typeStorage = dict()
    
    # Get the extension type tag parent containing all extension type tags
    typeTagParent = ParseTag(&#39;Extension Type&#39;)
    

    # Only select a subset of tags that correspond to files in the pruned tree
    if(prunedFileDf is not None):
        for row in prunedFileDf.iterrows():
            # Add each file to the appropriate type dict entry
            typeTagName = row[1][&#34;extensionSubtypeStr&#34;]
            try:
                typeNumber[typeTagName] += 1
            except KeyError:
                typeNumber[typeTagName] = 1
            try:
                typeStorage[typeTagName] += int(row[1][&#34;netSize&#34;])
            except KeyError:
                typeStorage[typeTagName] = int(row[1][&#34;netSize&#34;])
        # Add all parent types
        for subtype in list(typeNumber.keys()):
            parentTag = ParseTag(subtype).parentTag
            try:
                typeNumber[parentTag.tagName] += typeNumber[subtype]
            except KeyError:
                typeNumber[parentTag.tagName] = typeNumber[subtype]
            try:
                typeStorage[parentTag.tagName] += typeStorage[subtype]
            except KeyError:
                typeStorage[parentTag.tagName] = typeStorage[subtype]
    else:
        # Make histogram for the entire tree
        for typeTag in typeTagParent.childTags:
            # Count the number of files with this type tag
            typeNumber[typeTag.tagName] = len(typeTag.files)
            typeStorage[typeTag.tagName] = GetStorageForType(typeTag)
            # Add any subtypes (type/subtype will be separated later) 
            for subtype in typeTag.childTags:
                typeNumber[subtype.tagName] = len(subtype.files)
                typeStorage[subtype.tagName] = GetStorageForType(subtype)

    # Hide empty types    
    if(hideEmpty):
        for type in list(typeNumber.keys()):
            if(typeNumber[type] == 0):
                del typeNumber[type]
                del typeStorage[type]

    return typeNumber, typeStorage

def MakeExtensionTypeHistograms(prunedFileDf=None):
    &#39;&#39;&#39; 
    Description
    -----------
    Returns the HTML elements used for the Bokeh plots of the file type distributions. See bokeh documentation for more information about the components function.
    
    Args:
    -----
        prunedFileDf : pd.Dataframe : default=None
            #: Used if the tree has been pruned to update the distributions for the pruned tree
    
    &#39;&#39;&#39;  
    typeNumber, typeStorage = GetTypeFrequencies(prunedFileDf=prunedFileDf)

    # Split the type frequencies into type/subtype dicts
    subtypeFrequency = dict()
    subtypeStorage = dict()

    for type in list(typeNumber.keys()):
        if(not ParseTag(type).childTags):
            # Tag has no child tags - delete key and add to subtype dict FIXME(probably more efficient way to do this)
            subtypeFrequency[type] = typeNumber[type]
            subtypeStorage[type] = typeStorage[type]
            del typeNumber[type]
            del typeStorage[type]


    # Plot the number of files of each type
    numDist = PlotTypeNumberDist(typeNumber, typeStorage)
    # Plot the storage of each type
    sizeDist = PlotTypeStorageDist(typeNumber, typeStorage)

    # Plot number and storage for subtypes
    subtypeNumPlot = PlotSubtypeNumberDist(typeNumber, typeStorage, subtypeFrequency, subtypeStorage)
    subtypeSizePlot = PlotSubtypeStorageDist(typeNumber, typeStorage, subtypeFrequency, subtypeStorage)

    multiplotTypes = column(numDist, sizeDist, sizing_mode=&#34;stretch_both&#34;)
    multiplotSubtypes = column(subtypeNumPlot, subtypeSizePlot, sizing_mode=&#34;stretch_both&#34;)

    # Get the jscript and div container for this plot 
    typePlotComponents = components(multiplotTypes)
    subtypePlotComponents = components(multiplotSubtypes)

    return typePlotComponents, subtypePlotComponents


def PlotSubtypeNumberDist(typeNumber, typeStorage, subtypeNumber, subtypeStorage):
    &#39;&#39;&#39; 
    Description
    -----------
    Creates a Bokeh plot with interactive tooltip of the file subtype number distribution.
    
    Args:
    -----
        typeNumber : dict[str] = int
            #: dict with type (tagName) -&gt; number of files
        typeStorage : dict[str] = int
            #: dict with type (tagName) -&gt; storage occupied
        subtypeFrequency : dict[str] = int
            #: dict with subtype (tagName) -&gt; number of files
        subtypeStorage : dict[str] = int
            #: dict with subtype (tagName) -&gt; storage occupied
    
    Outputs:
    --------
        plot : bokeh.plotting.figure
            #: Bokeh figure instance    
    
    &#39;&#39;&#39; 
    typeNumber, typeStorage = SortDictsByNumber(typeNumber, typeStorage)

    # Create factor ranges for stacked plot 
    factors = list()
    typeList = list()
    numbers = list()
    sizes = list()
    
    for type in list(typeNumber.keys()):
        for subtype in ParseTag(type).childTags:
            # Only add if non zero (zero values were deleted from dict)
            if(subtype.tagName in subtypeNumber):
                factors.append((str(type), subtype.tagName))
                typeList.append(subtype.tagName)
                numbers.append(subtypeNumber[subtype.tagName])
                sizes.append(subtypeStorage[subtype.tagName])
    range = FactorRange(*factors)
    
    sizeStr = [size(_size) for _size in sizes]
    data = ColumnDataSource({&#39;types&#39;:factors, &#39;numbers&#39;:numbers, &#39;sizes&#39;:sizes, &#39;sizeStr&#39;:sizeStr, &#39;typeList&#39;:typeList})

    plot = figure(x_range=range, plot_height=max(numbers), title=&#34;File Subtype Number Distribution&#34;, 
        y_axis_label=&#34;Number of files&#34;,
        toolbar_location=None, tools=&#34;&#34;)

    plot.vbar(x=&#39;types&#39;, top=&#39;numbers&#39;, source=data, width=0.9)

    plot.y_range.start = 0
    plot.x_range.range_padding = 0.1
    plot.xaxis.major_label_orientation = 1
    plot.xgrid.grid_line_color = None

    # Add hover tooltip 
    plot.add_tools(HoverTool(
        tooltips=[
        ( &#39;Type&#39;,   &#39;@{typeList}&#39;   ),
        ( &#39;Number&#39;,  &#39;@{numbers}&#39;   ), 
        ( &#39;Storage&#39;, &#39;@{sizeStr}&#39;   ),
    ])
    )

    return plot

def PlotSubtypeStorageDist(typeNumber, typeStorage, subtypeNumber, subtypeStorage):
    &#39;&#39;&#39; 
    Description
    -----------
    Creates a Bokeh plot with interactive tooltip of the file subtype storage distribution.
    
    Args:
    -----
        typeNumber : dict[str] = int
            #: dict with type (tagName) -&gt; number of files
        typeStorage : dict[str] = int
            #: dict with type (tagName) -&gt; storage occupied
        subtypeNumber
         : dict[str] = int
            #: dict with subtype (tagName) -&gt; number of files
        subtypeStorage : dict[str] = int
            #: dict with subtype (tagName) -&gt; storage occupied
    
    Outputs:
    --------
        plot : bokeh.plotting.figure
            #: Bokeh figure instance    
    
    &#39;&#39;&#39; 
    typeNumber, typeStorage = SortDictsByStorage(typeNumber, typeStorage)

    # Create factor ranges for stacked plot 
    factors = list()
    typeList = list()
    numbers = []
    sizes = list()
    #sizes = list(subtypeStorage.values())
    
    for type in list(typeNumber.keys()):
        for subtype in ParseTag(type).childTags:
            # Only add if non zero (zero values were deleted from dict)
            if(subtype.tagName in subtypeNumber):
                factors.append((str(type), subtype.tagName))
                typeList.append(subtype.tagName)
                numbers.append(subtypeNumber[subtype.tagName])
                sizes.append(subtypeStorage[subtype.tagName])
    range = FactorRange(*factors)
    sizeStr = [size(_size) for _size in sizes]

    # Find the appropriate order of magnitude scale (floor(log10()) to find order of magnitude then floor(magnitude/3) to find range K, M, G etc)
    scale = floor((floor(log10(max(sizes))))/3)
    # Should not need beyond TB but included for completeness
    scaleStrDict = {0:&#34;Bytes&#34;, 1:&#34;KB&#34;, 2:&#34;MB&#34;, 3:&#34;GB&#34;, 4:&#34;TB&#34;, 5:&#34;PB&#34;}
    scaleStr = scaleStrDict[scale]
    scaledSizes = [size/(10**(scale*3)) for size in sizes]
    maxHeight = ceil(max(scaledSizes))


    data = ColumnDataSource({&#39;types&#39;:factors, &#39;sizes&#39;:scaledSizes, &#39;numbers&#39;:numbers, &#39;sizeStr&#39;:sizeStr, &#39;typeList&#39;:typeList})

    plot = figure(x_range=range, plot_height=maxHeight, title=&#34;File Subtype Storage Distribution&#34;, 
        y_axis_label=&#34;Storage occupied &#34; + scaleStr,
        toolbar_location=None, tools=&#34;&#34;
        )

    plot.vbar(x=&#39;types&#39;, top=&#39;sizes&#39;, source=data, width=0.9)

    plot.yaxis
    plot.y_range.start = 0
    plot.x_range.range_padding = 0.1
    plot.xaxis.major_label_orientation = 1
    plot.xgrid.grid_line_color = None

    # Add hover tooltip 
    plot.add_tools(HoverTool(
        tooltips=[
        ( &#39;Type&#39;,   &#39;@{typeList}&#39;   ),
        ( &#39;Number&#39;,  &#39;@{numbers}&#39;   ), 
        ( &#39;Storage&#39;, &#39;@{sizeStr}&#39;   ),
    ])
    )
    return plot


# Produce file type frequency plot (bokeh)
def PlotTypeNumberDist(typeNumber:dict, typeStorage:dict):
    &#39;&#39;&#39; 
    Description
    -----------
    Creates a Bokeh plot with interactive tooltip of the file type number distribution.
    
    Args:
    -----
        typeNumber : dict[str] = int
            #: dict with type (tagName) -&gt; number of files
        typeStorage : dict[str] = int
            #: dict with type (tagName) -&gt; storage occupied
        
    
    Outputs:
    --------
        plot : bokeh.plotting.figure
            #: Bokeh figure instance    
    
    &#39;&#39;&#39;    
    typeNumber, typeStorage = SortDictsByNumber(typeNumber, typeStorage)

    # Collect data for plot    
    types = list(typeNumber.keys())
    numbers = list(typeNumber.values())
    sizes = list(typeStorage.values())
    sizeStr = [size(_size) for _size in sizes]
    maxHeight = max(numbers)

    # Form column data source 
    data = ColumnDataSource({&#39;types&#39;:types, &#39;numbers&#39;:numbers, &#39;sizes&#39;:sizes, &#39;sizeStr&#39;:sizeStr})
    # Set up plot
    numPlot = figure(x_range = types, plot_height=maxHeight, title=&#34;File Type Number Distribution&#34;,
           y_axis_label=&#34;Number of files&#34;, 
           toolbar_location = None 
           )
    # Get the bar values (top) from the ColumnDataSource
    numPlot.vbar(x=&#39;types&#39;, top=&#39;numbers&#39;, source=data, width=0.75)
    # Add hover tooltip 
    numPlot.add_tools(HoverTool(
        tooltips=[
        ( &#39;Type&#39;,   &#39;@{types}&#39;           ),
        ( &#39;Number&#39;,  &#39;@{numbers}&#39;        ), 
        ( &#39;Storage&#39;, &#39;@{sizeStr}&#39;        ),
    ])
    )
    numPlot.xgrid.grid_line_color = None
    numPlot.y_range.start = 0
    numPlot.yaxis.axis_label_text_font_style = &#39;normal&#39;
    
    return numPlot
    #show(plot)

def PlotTypeStorageDist(typeNumber:dict, typeStorage:dict):
    &#39;&#39;&#39; 
    Description
    -----------
    Creates a Bokeh plot with interactive tooltip of the file type storage distribution.
    
    Args:
    -----
        typeNumber : dict[str] = int
            #: dict with type (tagName) -&gt; number of files
        typeStorage : dict[str] = int
            #: dict with type (tagName) -&gt; storage occupied
        
    
    Outputs:
    --------
        plot : bokeh.plotting.figure
            #: Bokeh figure instance    
    
    &#39;&#39;&#39;    
    # Sort the dicts based on storage amount values  
    typeNumber, typeStorage = SortDictsByStorage(typeNumber, typeStorage)
    
    # Collect data for plot    
    types = list(typeNumber.keys())
    numbers = list(typeNumber.values())
    sizes = list(typeStorage.values())
    sizeStr = [size(_size) for _size in sizes]
    
    # Find the appropriate order of magnitude scale (floor(log10()) to find order of magnitude then floor(magnitude/3) to find range K, M, G etc)
    scale = floor((floor(log10(max(sizes))))/3)
    # Should not need beyond TB but included for completeness
    scaleStrDict = {0:&#34;Bytes&#34;, 1:&#34;KB&#34;, 2:&#34;MB&#34;, 3:&#34;GB&#34;, 4:&#34;TB&#34;, 5:&#34;PB&#34;}
    scaleStr = scaleStrDict[scale]
    scaledSizes = [size/(pow(10,scale*3)) for size in sizes]
    maxHeight = ceil(max(scaledSizes))

    # Form column data source (scales sizes)
    data = ColumnDataSource({&#39;types&#39;:types, &#39;numbers&#39;:numbers, &#39;sizes&#39;:scaledSizes, &#39;sizeStr&#39;:sizeStr})
    # Set up plot
    sizePlot = figure(x_range = types, plot_height=maxHeight, title=&#34;File Type Storage Distribution&#34;,
           y_axis_label=&#34;Storage occupied &#34; + scaleStr, 
           toolbar_location = None #, tools=&#34;hover&#34;, tooltips=&#34;$name @types: @$name&#34;
           )
    # Get the bar values (top) from the ColumnDataSource
    sizePlot.vbar(x=&#39;types&#39;, top=&#39;sizes&#39;, source=data, width=0.75)
    # Add hover tooltip 
    sizePlot.add_tools(HoverTool(
        tooltips=[
        ( &#39;Type&#39;,   &#39;@{types}&#39;      ),
        ( &#39;Number&#39;,  &#39;@{numbers}&#39;   ), 
        ( &#39;Storage&#39;, &#39;@{sizeStr}&#39;   ),
    ])
    )
    sizePlot.xgrid.grid_line_color = None
    sizePlot.y_range.start = 0
    sizePlot.yaxis.axis_label_text_font_style = &#39;normal&#39;
    
    return sizePlot




# Old matplotlib versions
# def MatPlotTypeFrequencyDistribution(typeFrequency:dict, typeStorage:dict):


#     keyValueTuples = [(key, typeFrequency[key]) for key in list(typeFrequency.keys())]
#     sortedValues = gen.SortItemValueList(keyValueTuples, desc=True)
#     sortedTypeFreq = dict()
#     sortedTypeStorage = dict()
#     for type in sortedValues:
#         sortedTypeFreq[type] = typeFrequency[type]
#         sortedTypeStorage[type] = typeStorage[type]
#     typeFrequency = sortedTypeFreq
#     typeStorage = sortedTypeStorage

#     # Create bar plot showing type file frequency (labelled with type sizes)
#     fig1, ax1 = plt.subplots()
#     rects = ax1.bar(list(typeFrequency.keys()), typeFrequency.values(), color=&#39;b&#39;)
#     # Annotate each bar with the total storage amount
#     for bar, label in zip(rects, typeStorage.values()):
#         height = bar.get_height()
#         # Label bar with readable size value (using hurry.filesize.size)
#         ax1.text(bar.get_x() + bar.get_width() / 2, height*(1.01), size(label),
#             ha=&#39;center&#39;, va=&#39;bottom&#39;)

#     plt.ylabel(&#34;Number of files&#34;)
#     plt.xticks(rotation=65)
#     plt.title(&#34;Type frequency distribution with type storage labels&#34;)
    

# def MatPlotTypeSizeDistribution(typeFrequency:dict, typeStorage:dict):

#     keyValueTuples = [(key, typeStorage[key]) for key in list(typeStorage.keys())]
#     sortedValues = gen.SortItemValueList(keyValueTuples, desc=True)
#     sortedTypeFreq = dict()
#     sortedTypeStorage = dict()
#     for type in sortedValues:
#         sortedTypeFreq[type] = typeFrequency[type]
#         sortedTypeStorage[type] = typeStorage[type]
#     typeFrequency = sortedTypeFreq
#     typeStorage = sortedTypeStorage

#     # Create bar plot showing type size distribution (frequency labels)
#     fig2, ax2 = plt.subplots()
#     # Scale values to be in GB always
#     rects = ax2.bar(list(typeStorage.keys()), [value/1e+9 for value in typeStorage.values()], color=&#39;b&#39;)
#     # Annotate each bar with the total storage amount
#     for bar, label in zip(rects, typeFrequency.values()):
#         height = bar.get_height()
#         # Label bar with number of files
#         ax2.text(bar.get_x() + bar.get_width() / 2, height*(1.01), label,
#             ha=&#39;center&#39;, va=&#39;bottom&#39;)

#     plt.ylabel(&#34;Total storage (GB)&#34;)
    
#     plt.xticks(rotation=65)
#     plt.title(&#34;Type storage distribution with file frequency labels&#34;)
    



# ======================================================== #
# ======================= UTILITIES ====================== #
# ======================================================== #

# Get the tag associated with this tagName

def ParseTag(tag):
    &#39;&#39;&#39; 
    Description
    -----------
    Given a tag name string or actual Tag object, this returns the corresponding tag from the TAG_TREE.allTagsNameDict. 

    If no tag found this creates a new parentless tag with name &#34;Undefined-&#34; + tagName
    
    Args:
    -----
        tagName : str or Tag
            #: The name of the tag to parse (or actual Tag)
    
    Outputs:
    --------
        tag : Tag
            #: The corresponding Tag object  
    
    &#39;&#39;&#39; 
    
    # Get the appropriate tag object if passed string
    if(isinstance(tag, str)):
        try:
            tag = TAG_TREE.allTagsNameDict[tag]
        except KeyError:
            print(&#34;No such existing tag! #: Creating new parentless tag with name: Undefined-&#34; + tag)
            tag = Tag(&#34;Undefined-&#34; + tag)
        return tag        
    elif(isinstance(tag, Tag)):
        return tag

# Remove whitespace and &#39;.&#39; character from extensions
def ParseExtension(file):
    &#39;&#39;&#39; 
    Description
    -----------
    Parse and return the file extension as a string (with no &#39;.&#39; character)
    
    Args:
    -----
        file : File
            #: The file to parse the extension of
    
    Outputs:
    --------
        string : str
            #: The extension string with no &#39;.&#39; character
    
    &#39;&#39;&#39;
    
    ext = file.extension
    # Strip, lower and split on &#39;.&#39;
    split = (ext.strip().lower()).split(&#39;.&#39;)
    for string in split:
        # Check string is not empty or &#39;.&#39; character
        if(string and string != &#39;.&#39;):
            return string
    print(&#34;No extension! &#34; + ext + &#34;-- File: &#34; + file.path.absolute().as_posix())
    return None


# Sort the dicts based on the number of files of each type
def SortDictsByNumber(numberDict, storageDict):
    &#39;&#39;&#39; 
    Description
    -----------
    Sort the number and storage distributions in descending size order based on the number of files. Uses the general utlility method SortItemValueList.
    
    Args:
    -----
        numberDict : dict[str] = int
            #: The file (sub)type number distribution dict
        storageDict : dict[str] = int
            #: The file (sub)type storage distribution dict
    
    Outputs:
    --------
        sortedTypeNumber : dict[str] = int
            #: The sorted file (sub)type number distribution dict
        numberDict : dict[str] = int
            #: The sorted file (sub)type storage distribution dict
    
    &#39;&#39;&#39;
    
    # Sort the dicts of type -&gt; amount values based on number of files of each type 
    keyValueTuples = [(key, numberDict[key]) for key in list(numberDict.keys())]
    sortedValues = gen.SortItemValueList(keyValueTuples, desc=True)
    sortedTypeNumber = dict()
    sortedTypeStorage = dict()
    for type in sortedValues:
        sortedTypeNumber[type] = numberDict[type]
        sortedTypeStorage[type] = storageDict[type]
    return sortedTypeNumber, sortedTypeStorage


# Sort the dicts based on the storage of each type
def SortDictsByStorage(numberDict, storageDict):
    &#39;&#39;&#39; 
    Description
    -----------
    Sort the number and storage distributions in descending size order based on the storage occupied by the files. Uses the general utlility method SortItemValueList.
    
    Args:
    -----
        numberDict : dict[str] = int
            #: The file (sub)type number distribution dict
        storageDict : dict[str] = int
            #: The file (sub)type storage distribution dict
    
    Outputs:
    --------
        sortedTypeNumber : dict[str] = int
            #: The sorted file (sub)type number distribution dict
        numberDict : dict[str] = int
            #: The sorted file (sub)type storage distribution dict
    
    &#39;&#39;&#39;
    
    
    # Sort the dicts of type -&gt; amount values based on storage amount 
    keyValueTuples = [(key, storageDict[key]) for key in list(storageDict.keys())]
    sortedValues = gen.SortItemValueList(keyValueTuples, desc=True)
    sortedTypeNumber = dict()
    sortedTypeStorage = dict()
    for type in sortedValues:
        sortedTypeNumber[type] = numberDict[type]
        sortedTypeStorage[type] = storageDict[type]
    return sortedTypeNumber, sortedTypeStorage</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tagging.AddFobjectToParents"><code class="name flex">
<span>def <span class="ident">AddFobjectToParents</span></span>(<span>fobject, tag)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Recursively add this fobject to this tags parent tags list of fobjects.</p>
<h2 id="args">Args:</h2>
<pre><code>fobject : File or Folder
    #: The fobject to tag
tag : Tag
    #: The starting tag whose parents should be added to
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddFobjectToParents(fobject, tag):
    &#39;&#39;&#39; 
    Description
    -----------
    Recursively add this fobject to this tags parent tags list of fobjects.

    Args:
    -----
        fobject : File or Folder
            #: The fobject to tag
        tag : Tag
            #: The starting tag whose parents should be added to 
    
    &#39;&#39;&#39;
    if(tag.parentTag):
        # Add this fobject to the appropriate list of tagged files/folders
        if(isinstance(fobject, gen.File)):
            tag.parentTag.files.append(fobject)
        else:
            tag.parentTag.folders.append(fobject)
        # Recurse until no parent tags left
        AddFobjectToParents(fobject, tag.parentTag)</code></pre>
</details>
</dd>
<dt id="tagging.AssociateExtensionTypeTags"><code class="name flex">
<span>def <span class="ident">AssociateExtensionTypeTags</span></span>(<span>tagTree)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Read the data files located in the src/data folder used to define the extension type/subtype tags. </p>
<p>This method associates each extension type/subtype with the corresponding tag object (stored in the tagTree accross several dicts that map type &lt;-&gt; tag and subtype &lt;-&gt; tag). </p>
<h2 id="args">Args:</h2>
<pre><code>tagTree : TagTree
    #: The tag tree to store tag data within
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AssociateExtensionTypeTags(tagTree):
    &#39;&#39;&#39; 
    Description
    -----------
    Read the data files located in the src/data folder used to define the extension type/subtype tags. 

    This method associates each extension type/subtype with the corresponding tag object (stored in the tagTree accross several dicts that map type &lt;-&gt; tag and subtype &lt;-&gt; tag). 

    Args:
    -----
        tagTree : TagTree
            #: The tag tree to store tag data within
    
    &#39;&#39;&#39;   
    # Read the extension -&gt; subtype data from the excel file
    extensionTypeDf = pd.read_excel(Path(&#34;.&#34;) / &#34;src/fileorganiser/data/ExtensionSubtypeLabels.xls&#34;)
    
    # Dict for extension -&gt; type tag
    tagTree.extensionSubtypeDict = dict()
    # Dict for type tag -&gt; corresponding extension(s)
    tagTree.subtypeExtensionsDict = defaultdict(list)

    for row in extensionTypeDf.iterrows():
        ext = row[1][&#34;Extension&#34;]
        try:
            # Associate this extension with a (sub)type tag (type names in data spreadsheet must match tag type names!)
            tagTree.extensionSubtypeDict[ext] = tagTree.allTagsNameDict[row[1][&#34;SubType&#34;]]
        except KeyError:
            # Catch exception for bad type name data from spreadsheet (eg nan entries)
            print(&#34;Type name has no corresponding tag object! Type name: &#34; + str(row[1][&#34;SubType&#34;]) + &#34; #: Setting type as misc. &#34;)
            tagTree.extensionSubtypeDict[row[1][&#34;Extension&#34;]] = tagTree.allTagsNameDict[&#39;Misc&#39;]
        
        tagTree.subtypeExtensionsDict[row[1][&#34;SubType&#34;]].append(ext)</code></pre>
</details>
</dd>
<dt id="tagging.BuildExtensionTypeData"><code class="name flex">
<span>def <span class="ident">BuildExtensionTypeData</span></span>(<span>tagTree)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Read the data files located in the src/data folder used to define the extension type/subtype tags. </p>
<h2 id="args">Args:</h2>
<pre><code>tagTree : TagTree
    #: The tag tree to store tag data within
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BuildExtensionTypeData(tagTree):
    &#39;&#39;&#39; 
    Description
    -----------
    Read the data files located in the src/data folder used to define the extension type/subtype tags. 
    
    Args:
    -----
        tagTree : TagTree
            #: The tag tree to store tag data within
    
    &#39;&#39;&#39;
    # Read the type -&gt; subtypes definitions
    subtypeDefinitions = pd.read_excel(Path(&#34;.&#34;) / &#34;src/fileorganiser/data/ExtensionTypeSubtypesDefinitions.xls&#34;)

    # Read the extension types defined (column names)
    extTypes = list(subtypeDefinitions.columns)
    # Map each subtype to its parent type and vice versa
    
    for type in extTypes:
        # Iterate the list of subtypes for this type
        for subtype in subtypeDefinitions[type]:
            # Skip nan entries 
            if(str(subtype) == &#34;nan&#34;):
                continue
            else:
                # Set types that have no subtype to have subtype=type
                if(subtype == &#34;None&#34;):
                    tagTree.subtypeTypeDict[type] = type
                    tagTree.typeSubtypeDict[type].append(type)
                else:
                    tagTree.subtypeTypeDict[subtype] = type
                    tagTree.typeSubtypeDict[type].append(subtype)

    
    # Build all extension type tag objects
    CreateExtensionTypeTags(tagTree)
    # Associate extensions with the subtype tags
    AssociateExtensionTypeTags(tagTree)</code></pre>
</details>
</dd>
<dt id="tagging.ClearPreviousTags"><code class="name flex">
<span>def <span class="ident">ClearPreviousTags</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Clears the tag tree</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ClearPreviousTags():
    &#39;&#39;&#39; 
    Description
    -----------
    Clears the tag tree
    &#39;&#39;&#39;
    if(TAG_TREE):
        for tag in TAG_TREE.allTagsList:
            tag.files.clear()
            tag.folders.clear()</code></pre>
</details>
</dd>
<dt id="tagging.CreateExtensionTypeTags"><code class="name flex">
<span>def <span class="ident">CreateExtensionTypeTags</span></span>(<span>tagTree)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Read the data files located in the src/data folder used to define the extension type/subtype tags. </p>
<p>This method constructs the tag instance for each extension type/subtype
Args:</p>
<hr>
<pre><code>tagTree : TagTree
    #: The tag tree to store tag data within
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CreateExtensionTypeTags(tagTree):
    &#39;&#39;&#39; 
    Description
    -----------
    Read the data files located in the src/data folder used to define the extension type/subtype tags. 

    This method constructs the tag instance for each extension type/subtype
    Args:
    -----
        tagTree : TagTree
            #: The tag tree to store tag data within
    
    &#39;&#39;&#39;   
    # Extension type tag (all extensionTypes will be children of this tag)
    extensionTypeTag = Tag(&#39;Extension Type&#39;, tagTree=tagTree)
    
    # Create all extension type.subtype tags
    for extType in list(tagTree.typeSubtypeDict.keys()):
        # Create the tag object for this extension type
        tag = Tag(extType, parent=extensionTypeTag, tagTree=tagTree)
        # Create the subtype tags
        for subType in tagTree.typeSubtypeDict[extType]:
            subTag = Tag(subType, parent=tag, tagTree=tagTree)</code></pre>
</details>
</dd>
<dt id="tagging.GetStorageForType"><code class="name flex">
<span>def <span class="ident">GetStorageForType</span></span>(<span>typeTag: <a title="tagging.Tag" href="#tagging.Tag">Tag</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetStorageForType(typeTag:Tag):
    totalSize = 0
    for file in typeTag.files:
        totalSize += file.netSize
    return totalSize</code></pre>
</details>
</dd>
<dt id="tagging.GetTypeFrequencies"><code class="name flex">
<span>def <span class="ident">GetTypeFrequencies</span></span>(<span>hideEmpty=True, prunedFileDf=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Get the number of file of each extension type for constructing the distribution histograms, and the storage occupied by the files of each type.</p>
<h2 id="kwargs">Kwargs:</h2>
<pre><code>hideEmpty : bool : default=True
    #: Do not include types with zero files
prunedFileDf : pd.Dataframe : default=None
    #: Used if the tree has been pruned to update the distributions for the pruned tree
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>typeNumber : dict[str] = int
    #: dict with type (tagName) -&gt; number of files
typeStorage : dict[str] = int
    #: dict with type (tagName) -&gt; storage occupied
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetTypeFrequencies(hideEmpty=True, prunedFileDf=None):
    &#39;&#39;&#39; 
    Description
    -----------
    Get the number of file of each extension type for constructing the distribution histograms, and the storage occupied by the files of each type.
    
    Kwargs:
    -------
        hideEmpty : bool : default=True
            #: Do not include types with zero files
        prunedFileDf : pd.Dataframe : default=None
            #: Used if the tree has been pruned to update the distributions for the pruned tree
    
    Outputs:
    -------
        typeNumber : dict[str] = int
            #: dict with type (tagName) -&gt; number of files
        typeStorage : dict[str] = int
            #: dict with type (tagName) -&gt; storage occupied

    &#39;&#39;&#39; 
    typeNumber = dict()
    typeStorage = dict()
    
    # Get the extension type tag parent containing all extension type tags
    typeTagParent = ParseTag(&#39;Extension Type&#39;)
    

    # Only select a subset of tags that correspond to files in the pruned tree
    if(prunedFileDf is not None):
        for row in prunedFileDf.iterrows():
            # Add each file to the appropriate type dict entry
            typeTagName = row[1][&#34;extensionSubtypeStr&#34;]
            try:
                typeNumber[typeTagName] += 1
            except KeyError:
                typeNumber[typeTagName] = 1
            try:
                typeStorage[typeTagName] += int(row[1][&#34;netSize&#34;])
            except KeyError:
                typeStorage[typeTagName] = int(row[1][&#34;netSize&#34;])
        # Add all parent types
        for subtype in list(typeNumber.keys()):
            parentTag = ParseTag(subtype).parentTag
            try:
                typeNumber[parentTag.tagName] += typeNumber[subtype]
            except KeyError:
                typeNumber[parentTag.tagName] = typeNumber[subtype]
            try:
                typeStorage[parentTag.tagName] += typeStorage[subtype]
            except KeyError:
                typeStorage[parentTag.tagName] = typeStorage[subtype]
    else:
        # Make histogram for the entire tree
        for typeTag in typeTagParent.childTags:
            # Count the number of files with this type tag
            typeNumber[typeTag.tagName] = len(typeTag.files)
            typeStorage[typeTag.tagName] = GetStorageForType(typeTag)
            # Add any subtypes (type/subtype will be separated later) 
            for subtype in typeTag.childTags:
                typeNumber[subtype.tagName] = len(subtype.files)
                typeStorage[subtype.tagName] = GetStorageForType(subtype)

    # Hide empty types    
    if(hideEmpty):
        for type in list(typeNumber.keys()):
            if(typeNumber[type] == 0):
                del typeNumber[type]
                del typeStorage[type]

    return typeNumber, typeStorage</code></pre>
</details>
</dd>
<dt id="tagging.MakeExtensionTypeHistograms"><code class="name flex">
<span>def <span class="ident">MakeExtensionTypeHistograms</span></span>(<span>prunedFileDf=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Returns the HTML elements used for the Bokeh plots of the file type distributions. See bokeh documentation for more information about the components function.</p>
<h2 id="args">Args:</h2>
<pre><code>prunedFileDf : pd.Dataframe : default=None
    #: Used if the tree has been pruned to update the distributions for the pruned tree
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MakeExtensionTypeHistograms(prunedFileDf=None):
    &#39;&#39;&#39; 
    Description
    -----------
    Returns the HTML elements used for the Bokeh plots of the file type distributions. See bokeh documentation for more information about the components function.
    
    Args:
    -----
        prunedFileDf : pd.Dataframe : default=None
            #: Used if the tree has been pruned to update the distributions for the pruned tree
    
    &#39;&#39;&#39;  
    typeNumber, typeStorage = GetTypeFrequencies(prunedFileDf=prunedFileDf)

    # Split the type frequencies into type/subtype dicts
    subtypeFrequency = dict()
    subtypeStorage = dict()

    for type in list(typeNumber.keys()):
        if(not ParseTag(type).childTags):
            # Tag has no child tags - delete key and add to subtype dict FIXME(probably more efficient way to do this)
            subtypeFrequency[type] = typeNumber[type]
            subtypeStorage[type] = typeStorage[type]
            del typeNumber[type]
            del typeStorage[type]


    # Plot the number of files of each type
    numDist = PlotTypeNumberDist(typeNumber, typeStorage)
    # Plot the storage of each type
    sizeDist = PlotTypeStorageDist(typeNumber, typeStorage)

    # Plot number and storage for subtypes
    subtypeNumPlot = PlotSubtypeNumberDist(typeNumber, typeStorage, subtypeFrequency, subtypeStorage)
    subtypeSizePlot = PlotSubtypeStorageDist(typeNumber, typeStorage, subtypeFrequency, subtypeStorage)

    multiplotTypes = column(numDist, sizeDist, sizing_mode=&#34;stretch_both&#34;)
    multiplotSubtypes = column(subtypeNumPlot, subtypeSizePlot, sizing_mode=&#34;stretch_both&#34;)

    # Get the jscript and div container for this plot 
    typePlotComponents = components(multiplotTypes)
    subtypePlotComponents = components(multiplotSubtypes)

    return typePlotComponents, subtypePlotComponents</code></pre>
</details>
</dd>
<dt id="tagging.ParseExtension"><code class="name flex">
<span>def <span class="ident">ParseExtension</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Parse and return the file extension as a string (with no '.' character)</p>
<h2 id="args">Args:</h2>
<pre><code>file : File
    #: The file to parse the extension of
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>string : str
    #: The extension string with no '.' character
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ParseExtension(file):
    &#39;&#39;&#39; 
    Description
    -----------
    Parse and return the file extension as a string (with no &#39;.&#39; character)
    
    Args:
    -----
        file : File
            #: The file to parse the extension of
    
    Outputs:
    --------
        string : str
            #: The extension string with no &#39;.&#39; character
    
    &#39;&#39;&#39;
    
    ext = file.extension
    # Strip, lower and split on &#39;.&#39;
    split = (ext.strip().lower()).split(&#39;.&#39;)
    for string in split:
        # Check string is not empty or &#39;.&#39; character
        if(string and string != &#39;.&#39;):
            return string
    print(&#34;No extension! &#34; + ext + &#34;-- File: &#34; + file.path.absolute().as_posix())
    return None</code></pre>
</details>
</dd>
<dt id="tagging.ParseTag"><code class="name flex">
<span>def <span class="ident">ParseTag</span></span>(<span>tag)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Given a tag name string or actual Tag object, this returns the corresponding tag from the TAG_TREE.allTagsNameDict. </p>
<p>If no tag found this creates a new parentless tag with name "Undefined-" + tagName</p>
<h2 id="args">Args:</h2>
<pre><code>tagName : str or Tag
    #: The name of the tag to parse (or actual Tag)
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>tag : Tag
    #: The corresponding Tag object
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ParseTag(tag):
    &#39;&#39;&#39; 
    Description
    -----------
    Given a tag name string or actual Tag object, this returns the corresponding tag from the TAG_TREE.allTagsNameDict. 

    If no tag found this creates a new parentless tag with name &#34;Undefined-&#34; + tagName
    
    Args:
    -----
        tagName : str or Tag
            #: The name of the tag to parse (or actual Tag)
    
    Outputs:
    --------
        tag : Tag
            #: The corresponding Tag object  
    
    &#39;&#39;&#39; 
    
    # Get the appropriate tag object if passed string
    if(isinstance(tag, str)):
        try:
            tag = TAG_TREE.allTagsNameDict[tag]
        except KeyError:
            print(&#34;No such existing tag! #: Creating new parentless tag with name: Undefined-&#34; + tag)
            tag = Tag(&#34;Undefined-&#34; + tag)
        return tag        
    elif(isinstance(tag, Tag)):
        return tag</code></pre>
</details>
</dd>
<dt id="tagging.PlotSubtypeNumberDist"><code class="name flex">
<span>def <span class="ident">PlotSubtypeNumberDist</span></span>(<span>typeNumber, typeStorage, subtypeNumber, subtypeStorage)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Creates a Bokeh plot with interactive tooltip of the file subtype number distribution.</p>
<h2 id="args">Args:</h2>
<pre><code>typeNumber : dict[str] = int
    #: dict with type (tagName) -&gt; number of files
typeStorage : dict[str] = int
    #: dict with type (tagName) -&gt; storage occupied
subtypeFrequency : dict[str] = int
    #: dict with subtype (tagName) -&gt; number of files
subtypeStorage : dict[str] = int
    #: dict with subtype (tagName) -&gt; storage occupied
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>plot : bokeh.plotting.figure
    #: Bokeh figure instance
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PlotSubtypeNumberDist(typeNumber, typeStorage, subtypeNumber, subtypeStorage):
    &#39;&#39;&#39; 
    Description
    -----------
    Creates a Bokeh plot with interactive tooltip of the file subtype number distribution.
    
    Args:
    -----
        typeNumber : dict[str] = int
            #: dict with type (tagName) -&gt; number of files
        typeStorage : dict[str] = int
            #: dict with type (tagName) -&gt; storage occupied
        subtypeFrequency : dict[str] = int
            #: dict with subtype (tagName) -&gt; number of files
        subtypeStorage : dict[str] = int
            #: dict with subtype (tagName) -&gt; storage occupied
    
    Outputs:
    --------
        plot : bokeh.plotting.figure
            #: Bokeh figure instance    
    
    &#39;&#39;&#39; 
    typeNumber, typeStorage = SortDictsByNumber(typeNumber, typeStorage)

    # Create factor ranges for stacked plot 
    factors = list()
    typeList = list()
    numbers = list()
    sizes = list()
    
    for type in list(typeNumber.keys()):
        for subtype in ParseTag(type).childTags:
            # Only add if non zero (zero values were deleted from dict)
            if(subtype.tagName in subtypeNumber):
                factors.append((str(type), subtype.tagName))
                typeList.append(subtype.tagName)
                numbers.append(subtypeNumber[subtype.tagName])
                sizes.append(subtypeStorage[subtype.tagName])
    range = FactorRange(*factors)
    
    sizeStr = [size(_size) for _size in sizes]
    data = ColumnDataSource({&#39;types&#39;:factors, &#39;numbers&#39;:numbers, &#39;sizes&#39;:sizes, &#39;sizeStr&#39;:sizeStr, &#39;typeList&#39;:typeList})

    plot = figure(x_range=range, plot_height=max(numbers), title=&#34;File Subtype Number Distribution&#34;, 
        y_axis_label=&#34;Number of files&#34;,
        toolbar_location=None, tools=&#34;&#34;)

    plot.vbar(x=&#39;types&#39;, top=&#39;numbers&#39;, source=data, width=0.9)

    plot.y_range.start = 0
    plot.x_range.range_padding = 0.1
    plot.xaxis.major_label_orientation = 1
    plot.xgrid.grid_line_color = None

    # Add hover tooltip 
    plot.add_tools(HoverTool(
        tooltips=[
        ( &#39;Type&#39;,   &#39;@{typeList}&#39;   ),
        ( &#39;Number&#39;,  &#39;@{numbers}&#39;   ), 
        ( &#39;Storage&#39;, &#39;@{sizeStr}&#39;   ),
    ])
    )

    return plot</code></pre>
</details>
</dd>
<dt id="tagging.PlotSubtypeStorageDist"><code class="name flex">
<span>def <span class="ident">PlotSubtypeStorageDist</span></span>(<span>typeNumber, typeStorage, subtypeNumber, subtypeStorage)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Creates a Bokeh plot with interactive tooltip of the file subtype storage distribution.</p>
<h2 id="args">Args:</h2>
<pre><code>typeNumber : dict[str] = int
    #: dict with type (tagName) -&gt; number of files
typeStorage : dict[str] = int
    #: dict with type (tagName) -&gt; storage occupied
subtypeNumber
 : dict[str] = int
    #: dict with subtype (tagName) -&gt; number of files
subtypeStorage : dict[str] = int
    #: dict with subtype (tagName) -&gt; storage occupied
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>plot : bokeh.plotting.figure
    #: Bokeh figure instance
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PlotSubtypeStorageDist(typeNumber, typeStorage, subtypeNumber, subtypeStorage):
    &#39;&#39;&#39; 
    Description
    -----------
    Creates a Bokeh plot with interactive tooltip of the file subtype storage distribution.
    
    Args:
    -----
        typeNumber : dict[str] = int
            #: dict with type (tagName) -&gt; number of files
        typeStorage : dict[str] = int
            #: dict with type (tagName) -&gt; storage occupied
        subtypeNumber
         : dict[str] = int
            #: dict with subtype (tagName) -&gt; number of files
        subtypeStorage : dict[str] = int
            #: dict with subtype (tagName) -&gt; storage occupied
    
    Outputs:
    --------
        plot : bokeh.plotting.figure
            #: Bokeh figure instance    
    
    &#39;&#39;&#39; 
    typeNumber, typeStorage = SortDictsByStorage(typeNumber, typeStorage)

    # Create factor ranges for stacked plot 
    factors = list()
    typeList = list()
    numbers = []
    sizes = list()
    #sizes = list(subtypeStorage.values())
    
    for type in list(typeNumber.keys()):
        for subtype in ParseTag(type).childTags:
            # Only add if non zero (zero values were deleted from dict)
            if(subtype.tagName in subtypeNumber):
                factors.append((str(type), subtype.tagName))
                typeList.append(subtype.tagName)
                numbers.append(subtypeNumber[subtype.tagName])
                sizes.append(subtypeStorage[subtype.tagName])
    range = FactorRange(*factors)
    sizeStr = [size(_size) for _size in sizes]

    # Find the appropriate order of magnitude scale (floor(log10()) to find order of magnitude then floor(magnitude/3) to find range K, M, G etc)
    scale = floor((floor(log10(max(sizes))))/3)
    # Should not need beyond TB but included for completeness
    scaleStrDict = {0:&#34;Bytes&#34;, 1:&#34;KB&#34;, 2:&#34;MB&#34;, 3:&#34;GB&#34;, 4:&#34;TB&#34;, 5:&#34;PB&#34;}
    scaleStr = scaleStrDict[scale]
    scaledSizes = [size/(10**(scale*3)) for size in sizes]
    maxHeight = ceil(max(scaledSizes))


    data = ColumnDataSource({&#39;types&#39;:factors, &#39;sizes&#39;:scaledSizes, &#39;numbers&#39;:numbers, &#39;sizeStr&#39;:sizeStr, &#39;typeList&#39;:typeList})

    plot = figure(x_range=range, plot_height=maxHeight, title=&#34;File Subtype Storage Distribution&#34;, 
        y_axis_label=&#34;Storage occupied &#34; + scaleStr,
        toolbar_location=None, tools=&#34;&#34;
        )

    plot.vbar(x=&#39;types&#39;, top=&#39;sizes&#39;, source=data, width=0.9)

    plot.yaxis
    plot.y_range.start = 0
    plot.x_range.range_padding = 0.1
    plot.xaxis.major_label_orientation = 1
    plot.xgrid.grid_line_color = None

    # Add hover tooltip 
    plot.add_tools(HoverTool(
        tooltips=[
        ( &#39;Type&#39;,   &#39;@{typeList}&#39;   ),
        ( &#39;Number&#39;,  &#39;@{numbers}&#39;   ), 
        ( &#39;Storage&#39;, &#39;@{sizeStr}&#39;   ),
    ])
    )
    return plot</code></pre>
</details>
</dd>
<dt id="tagging.PlotTypeNumberDist"><code class="name flex">
<span>def <span class="ident">PlotTypeNumberDist</span></span>(<span>typeNumber: dict, typeStorage: dict)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Creates a Bokeh plot with interactive tooltip of the file type number distribution.</p>
<h2 id="args">Args:</h2>
<pre><code>typeNumber : dict[str] = int
    #: dict with type (tagName) -&gt; number of files
typeStorage : dict[str] = int
    #: dict with type (tagName) -&gt; storage occupied
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>plot : bokeh.plotting.figure
    #: Bokeh figure instance
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PlotTypeNumberDist(typeNumber:dict, typeStorage:dict):
    &#39;&#39;&#39; 
    Description
    -----------
    Creates a Bokeh plot with interactive tooltip of the file type number distribution.
    
    Args:
    -----
        typeNumber : dict[str] = int
            #: dict with type (tagName) -&gt; number of files
        typeStorage : dict[str] = int
            #: dict with type (tagName) -&gt; storage occupied
        
    
    Outputs:
    --------
        plot : bokeh.plotting.figure
            #: Bokeh figure instance    
    
    &#39;&#39;&#39;    
    typeNumber, typeStorage = SortDictsByNumber(typeNumber, typeStorage)

    # Collect data for plot    
    types = list(typeNumber.keys())
    numbers = list(typeNumber.values())
    sizes = list(typeStorage.values())
    sizeStr = [size(_size) for _size in sizes]
    maxHeight = max(numbers)

    # Form column data source 
    data = ColumnDataSource({&#39;types&#39;:types, &#39;numbers&#39;:numbers, &#39;sizes&#39;:sizes, &#39;sizeStr&#39;:sizeStr})
    # Set up plot
    numPlot = figure(x_range = types, plot_height=maxHeight, title=&#34;File Type Number Distribution&#34;,
           y_axis_label=&#34;Number of files&#34;, 
           toolbar_location = None 
           )
    # Get the bar values (top) from the ColumnDataSource
    numPlot.vbar(x=&#39;types&#39;, top=&#39;numbers&#39;, source=data, width=0.75)
    # Add hover tooltip 
    numPlot.add_tools(HoverTool(
        tooltips=[
        ( &#39;Type&#39;,   &#39;@{types}&#39;           ),
        ( &#39;Number&#39;,  &#39;@{numbers}&#39;        ), 
        ( &#39;Storage&#39;, &#39;@{sizeStr}&#39;        ),
    ])
    )
    numPlot.xgrid.grid_line_color = None
    numPlot.y_range.start = 0
    numPlot.yaxis.axis_label_text_font_style = &#39;normal&#39;
    
    return numPlot
    #show(plot)</code></pre>
</details>
</dd>
<dt id="tagging.PlotTypeStorageDist"><code class="name flex">
<span>def <span class="ident">PlotTypeStorageDist</span></span>(<span>typeNumber: dict, typeStorage: dict)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Creates a Bokeh plot with interactive tooltip of the file type storage distribution.</p>
<h2 id="args">Args:</h2>
<pre><code>typeNumber : dict[str] = int
    #: dict with type (tagName) -&gt; number of files
typeStorage : dict[str] = int
    #: dict with type (tagName) -&gt; storage occupied
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>plot : bokeh.plotting.figure
    #: Bokeh figure instance
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PlotTypeStorageDist(typeNumber:dict, typeStorage:dict):
    &#39;&#39;&#39; 
    Description
    -----------
    Creates a Bokeh plot with interactive tooltip of the file type storage distribution.
    
    Args:
    -----
        typeNumber : dict[str] = int
            #: dict with type (tagName) -&gt; number of files
        typeStorage : dict[str] = int
            #: dict with type (tagName) -&gt; storage occupied
        
    
    Outputs:
    --------
        plot : bokeh.plotting.figure
            #: Bokeh figure instance    
    
    &#39;&#39;&#39;    
    # Sort the dicts based on storage amount values  
    typeNumber, typeStorage = SortDictsByStorage(typeNumber, typeStorage)
    
    # Collect data for plot    
    types = list(typeNumber.keys())
    numbers = list(typeNumber.values())
    sizes = list(typeStorage.values())
    sizeStr = [size(_size) for _size in sizes]
    
    # Find the appropriate order of magnitude scale (floor(log10()) to find order of magnitude then floor(magnitude/3) to find range K, M, G etc)
    scale = floor((floor(log10(max(sizes))))/3)
    # Should not need beyond TB but included for completeness
    scaleStrDict = {0:&#34;Bytes&#34;, 1:&#34;KB&#34;, 2:&#34;MB&#34;, 3:&#34;GB&#34;, 4:&#34;TB&#34;, 5:&#34;PB&#34;}
    scaleStr = scaleStrDict[scale]
    scaledSizes = [size/(pow(10,scale*3)) for size in sizes]
    maxHeight = ceil(max(scaledSizes))

    # Form column data source (scales sizes)
    data = ColumnDataSource({&#39;types&#39;:types, &#39;numbers&#39;:numbers, &#39;sizes&#39;:scaledSizes, &#39;sizeStr&#39;:sizeStr})
    # Set up plot
    sizePlot = figure(x_range = types, plot_height=maxHeight, title=&#34;File Type Storage Distribution&#34;,
           y_axis_label=&#34;Storage occupied &#34; + scaleStr, 
           toolbar_location = None #, tools=&#34;hover&#34;, tooltips=&#34;$name @types: @$name&#34;
           )
    # Get the bar values (top) from the ColumnDataSource
    sizePlot.vbar(x=&#39;types&#39;, top=&#39;sizes&#39;, source=data, width=0.75)
    # Add hover tooltip 
    sizePlot.add_tools(HoverTool(
        tooltips=[
        ( &#39;Type&#39;,   &#39;@{types}&#39;      ),
        ( &#39;Number&#39;,  &#39;@{numbers}&#39;   ), 
        ( &#39;Storage&#39;, &#39;@{sizeStr}&#39;   ),
    ])
    )
    sizePlot.xgrid.grid_line_color = None
    sizePlot.y_range.start = 0
    sizePlot.yaxis.axis_label_text_font_style = &#39;normal&#39;
    
    return sizePlot</code></pre>
</details>
</dd>
<dt id="tagging.SortDictsByNumber"><code class="name flex">
<span>def <span class="ident">SortDictsByNumber</span></span>(<span>numberDict, storageDict)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Sort the number and storage distributions in descending size order based on the number of files. Uses the general utlility method SortItemValueList.</p>
<h2 id="args">Args:</h2>
<pre><code>numberDict : dict[str] = int
    #: The file (sub)type number distribution dict
storageDict : dict[str] = int
    #: The file (sub)type storage distribution dict
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>sortedTypeNumber : dict[str] = int
    #: The sorted file (sub)type number distribution dict
numberDict : dict[str] = int
    #: The sorted file (sub)type storage distribution dict
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SortDictsByNumber(numberDict, storageDict):
    &#39;&#39;&#39; 
    Description
    -----------
    Sort the number and storage distributions in descending size order based on the number of files. Uses the general utlility method SortItemValueList.
    
    Args:
    -----
        numberDict : dict[str] = int
            #: The file (sub)type number distribution dict
        storageDict : dict[str] = int
            #: The file (sub)type storage distribution dict
    
    Outputs:
    --------
        sortedTypeNumber : dict[str] = int
            #: The sorted file (sub)type number distribution dict
        numberDict : dict[str] = int
            #: The sorted file (sub)type storage distribution dict
    
    &#39;&#39;&#39;
    
    # Sort the dicts of type -&gt; amount values based on number of files of each type 
    keyValueTuples = [(key, numberDict[key]) for key in list(numberDict.keys())]
    sortedValues = gen.SortItemValueList(keyValueTuples, desc=True)
    sortedTypeNumber = dict()
    sortedTypeStorage = dict()
    for type in sortedValues:
        sortedTypeNumber[type] = numberDict[type]
        sortedTypeStorage[type] = storageDict[type]
    return sortedTypeNumber, sortedTypeStorage</code></pre>
</details>
</dd>
<dt id="tagging.SortDictsByStorage"><code class="name flex">
<span>def <span class="ident">SortDictsByStorage</span></span>(<span>numberDict, storageDict)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Sort the number and storage distributions in descending size order based on the storage occupied by the files. Uses the general utlility method SortItemValueList.</p>
<h2 id="args">Args:</h2>
<pre><code>numberDict : dict[str] = int
    #: The file (sub)type number distribution dict
storageDict : dict[str] = int
    #: The file (sub)type storage distribution dict
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>sortedTypeNumber : dict[str] = int
    #: The sorted file (sub)type number distribution dict
numberDict : dict[str] = int
    #: The sorted file (sub)type storage distribution dict
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SortDictsByStorage(numberDict, storageDict):
    &#39;&#39;&#39; 
    Description
    -----------
    Sort the number and storage distributions in descending size order based on the storage occupied by the files. Uses the general utlility method SortItemValueList.
    
    Args:
    -----
        numberDict : dict[str] = int
            #: The file (sub)type number distribution dict
        storageDict : dict[str] = int
            #: The file (sub)type storage distribution dict
    
    Outputs:
    --------
        sortedTypeNumber : dict[str] = int
            #: The sorted file (sub)type number distribution dict
        numberDict : dict[str] = int
            #: The sorted file (sub)type storage distribution dict
    
    &#39;&#39;&#39;
    
    
    # Sort the dicts of type -&gt; amount values based on storage amount 
    keyValueTuples = [(key, storageDict[key]) for key in list(storageDict.keys())]
    sortedValues = gen.SortItemValueList(keyValueTuples, desc=True)
    sortedTypeNumber = dict()
    sortedTypeStorage = dict()
    for type in sortedValues:
        sortedTypeNumber[type] = numberDict[type]
        sortedTypeStorage[type] = storageDict[type]
    return sortedTypeNumber, sortedTypeStorage</code></pre>
</details>
</dd>
<dt id="tagging.TagByExtensionSubtype"><code class="name flex">
<span>def <span class="ident">TagByExtensionSubtype</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Using the definitions defined in the TAG_TREE, tag a given file based on its extension (subtype).</p>
<h2 id="args">Args:</h2>
<pre><code>file : File
    #: The file to be tagged
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TagByExtensionSubtype(file):
    &#39;&#39;&#39; 
    Description
    -----------
    Using the definitions defined in the TAG_TREE, tag a given file based on its extension (subtype).
    
    Args:
    -----
        file : File
            #: The file to be tagged
    
    &#39;&#39;&#39;   
    extension = ParseExtension(file)

    try:
        # Set the extension type attribute
        extensionTypeTag = TAG_TREE.extensionSubtypeDict[extension]
        # Tag the file with this extension type tag
        TagFobject(file, TAG_TREE.extensionSubtypeDict[extension].tagName)
    except KeyError:
        #print(&#34;Extension has no associated type! Ext: &#34; + str(extension))
        # Give the unknown extension type the misc tag
        extensionTypeTag = TAG_TREE.allTagsNameDict[&#39;Misc&#39;]
        TagFobject(file, &#39;Misc&#39;)
        # Log this uncategorised extension to the typeExtensionsDict
        if(extension not in TAG_TREE.subtypeExtensionsDict[&#39;Misc&#39;]):
            TAG_TREE.subtypeExtensionsDict[&#39;Misc&#39;].append(extension)
    return extensionTypeTag</code></pre>
</details>
</dd>
<dt id="tagging.TagFobject"><code class="name flex">
<span>def <span class="ident">TagFobject</span></span>(<span>fobject, tagName)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Assign the specified tag (referenced by tag name) to the given fobject.</p>
<p>Assigning a tag that has parents will recursively add this fobject to the parent tags list of fobjects.</p>
<h2 id="args">Args:</h2>
<pre><code>fobject : File or Folder
    #: The fobject to tag
tagName : str
    #: The name of the tag to assign
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TagFobject(fobject, tagName):
    &#39;&#39;&#39; 
        Description
        -----------
        Assign the specified tag (referenced by tag name) to the given fobject.

        Assigning a tag that has parents will recursively add this fobject to the parent tags list of fobjects.

        Args:
        -----
            fobject : File or Folder
                #: The fobject to tag
            tagName : str
                #: The name of the tag to assign
       
    &#39;&#39;&#39;
    # Get the appropriate tag object if passed string
    if(isinstance(tagName, str)):
        try:
            tagName = TAG_TREE.allTagsNameDict[tagName]
        except KeyError:
            print(&#34;No such existing tag! #: Creating new parentless tag with name: &#34; + tagName)
            tagName = Tag(tagName)

    # Add this tag to the fobject list of tags
    fobject.tags.append(tagName)
    
    # Add this fobject to the appropriate list of tagged files/folders
    if(isinstance(fobject, gen.File)):
        tagName.files.append(fobject)
    else:
        tagName.folders.append(fobject)
    
    # Add this fobject to the parent tag list (recursively)
    AddFobjectToParents(fobject, tagName)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tagging.Tag"><code class="flex name class">
<span>class <span class="ident">Tag</span></span>
<span>(</span><span>tagName, parent=None, tagTree=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="class">Class:</h2>
<p>Defines a single Tag object, contains a reference to the parent and child tags of this tag (if appropriate).</p>
<p>Each tag also contains a list of all the files/folders with this particular tag.</p>
<h2 id="description">Description</h2>
<p>Constructor for the Tag object, tag is constructed using the tag name and a reference to its parent tag (if any).</p>
<p>If a tag tree is specified, this constructor will update the tagTree.allTagsList and tagTree.allTagsNameDict attributes on the tree.</p>
<h2 id="args">Args:</h2>
<pre><code>tagName : str
    #: The name of this tag
</code></pre>
<h2 id="kwargs">Kwargs:</h2>
<pre><code>parent : Tag : default=None
    #: The parent of this tag (if any)
tagTree : TagTree : default=None
    #: The tag tree this tag belongs to (if any)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tag():
    &#39;&#39;&#39;
    Class:
    ------
    Defines a single Tag object, contains a reference to the parent and child tags of this tag (if appropriate).

    Each tag also contains a list of all the files/folders with this particular tag.
    
    &#39;&#39;&#39;
    
    def __init__(self, tagName, parent=None, tagTree=None):
        &#39;&#39;&#39; 
        Description
        -----------
        Constructor for the Tag object, tag is constructed using the tag name and a reference to its parent tag (if any).

        If a tag tree is specified, this constructor will update the tagTree.allTagsList and tagTree.allTagsNameDict attributes on the tree.

        Args:
        -----
            tagName : str
                #: The name of this tag
        Kwargs:
        -------
            parent : Tag : default=None
                #: The parent of this tag (if any)
            tagTree : TagTree : default=None
                #: The tag tree this tag belongs to (if any)
        
        &#39;&#39;&#39;
        
        # Add to tag tree
        if(tagTree):
            tagTree.allTagsList.append(self)
            tagTree.allTagsNameDict[tagName] = self
        
        # Tag name
        self.tagName = tagName
        # Parent tag in heirachy (if defined)
        self.parentTag = parent
        # If parent was set, add this tag to the child tags of the parent
        if(parent):
            parent.childTags.append(self)
        # Child tags
        self.childTags = list()
        # TagTree depth (depth from tagtree root)
        self.tagDepth = 1
        
        

        # Files with this tag
        self.files = list()
        # Folders with this tag
        self.folders = list()</code></pre>
</details>
</dd>
<dt id="tagging.TagTree"><code class="flex name class">
<span>class <span class="ident">TagTree</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="class">Class:</h2>
<p>This class stores the hierachical relationship between tags in a parent/child structure.</p>
<p>This class also stores the definitions for the extension type &lt;-&gt; tag and subtype &lt;-&gt; tag read from the data files in the src/data folder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TagTree():
    &#39;&#39;&#39;
    Class:
    ------
    This class stores the hierachical relationship between tags in a parent/child structure.

    This class also stores the definitions for the extension type &lt;-&gt; tag and subtype &lt;-&gt; tag read from the data files in the src/data folder.

    &#39;&#39;&#39;
    def __init__(self):
        # List of all tags 
        self.allTagsList = list()
        # Dict to access tags by name (name str -&gt; tag)
        self.allTagsNameDict = dict()
        
        # Dicts of type -&gt; subtype and vice versa
        self.subtypeTypeDict = dict()
        self.typeSubtypeDict = defaultdict(list)
        # Dict for extension -&gt; subtype tag and vice versa
        self.extensionSubtypeDict = dict()
        self.subtypeExtensionsDict = defaultdict(list)
        
        # Function that builds the previously defined dicts
        BuildExtensionTypeData(self)
               
        # Dict of keywords -&gt; tag
        self.keywordsTagDict = dict()</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fileorganiser" href="index.html">fileorganiser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tagging.AddFobjectToParents" href="#tagging.AddFobjectToParents">AddFobjectToParents</a></code></li>
<li><code><a title="tagging.AssociateExtensionTypeTags" href="#tagging.AssociateExtensionTypeTags">AssociateExtensionTypeTags</a></code></li>
<li><code><a title="tagging.BuildExtensionTypeData" href="#tagging.BuildExtensionTypeData">BuildExtensionTypeData</a></code></li>
<li><code><a title="tagging.ClearPreviousTags" href="#tagging.ClearPreviousTags">ClearPreviousTags</a></code></li>
<li><code><a title="tagging.CreateExtensionTypeTags" href="#tagging.CreateExtensionTypeTags">CreateExtensionTypeTags</a></code></li>
<li><code><a title="tagging.GetStorageForType" href="#tagging.GetStorageForType">GetStorageForType</a></code></li>
<li><code><a title="tagging.GetTypeFrequencies" href="#tagging.GetTypeFrequencies">GetTypeFrequencies</a></code></li>
<li><code><a title="tagging.MakeExtensionTypeHistograms" href="#tagging.MakeExtensionTypeHistograms">MakeExtensionTypeHistograms</a></code></li>
<li><code><a title="tagging.ParseExtension" href="#tagging.ParseExtension">ParseExtension</a></code></li>
<li><code><a title="tagging.ParseTag" href="#tagging.ParseTag">ParseTag</a></code></li>
<li><code><a title="tagging.PlotSubtypeNumberDist" href="#tagging.PlotSubtypeNumberDist">PlotSubtypeNumberDist</a></code></li>
<li><code><a title="tagging.PlotSubtypeStorageDist" href="#tagging.PlotSubtypeStorageDist">PlotSubtypeStorageDist</a></code></li>
<li><code><a title="tagging.PlotTypeNumberDist" href="#tagging.PlotTypeNumberDist">PlotTypeNumberDist</a></code></li>
<li><code><a title="tagging.PlotTypeStorageDist" href="#tagging.PlotTypeStorageDist">PlotTypeStorageDist</a></code></li>
<li><code><a title="tagging.SortDictsByNumber" href="#tagging.SortDictsByNumber">SortDictsByNumber</a></code></li>
<li><code><a title="tagging.SortDictsByStorage" href="#tagging.SortDictsByStorage">SortDictsByStorage</a></code></li>
<li><code><a title="tagging.TagByExtensionSubtype" href="#tagging.TagByExtensionSubtype">TagByExtensionSubtype</a></code></li>
<li><code><a title="tagging.TagFobject" href="#tagging.TagFobject">TagFobject</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tagging.Tag" href="#tagging.Tag">Tag</a></code></h4>
</li>
<li>
<h4><code><a title="tagging.TagTree" href="#tagging.TagTree">TagTree</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>