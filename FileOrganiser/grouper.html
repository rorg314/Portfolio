<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>grouper API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grouper</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import defaultdict

from math import floor
import shutil
from iteration_utilities import unique_everseen, duplicates


from src.fileorganiser.tagging import TAG_TREE, ParseTag
from src.fileorganiser.general import *
from src.fileorganiser.search import *



# ======================================================== #
# ===================== FILE GROUPING ==================== #
# ======================================================== #
&#39;&#39;&#39;
This script contains functionality for grouping and sorting files based on 
the user defined sort hierarchy.
&#39;&#39;&#39;


# Defines the possible sort groups
SORT_GROUPS = [&#34;Date Created&#34;, &#34;Date Modified&#34;, &#34;Time&#34;, &#34;Type&#34;, &#34;Subtype&#34;, &#34;Size&#34;, &#34;Alphabetical&#34;, &#34;Extension&#34;, &#34;Keyword&#34; ]




# ======================================================== #
# ===================== GROUP METHODS ==================== #
# ======================================================== #
&#39;&#39;&#39;
These methods perform the respective groupings on a list of input files. All return a dict {groupName:groupFiles}

&#39;&#39;&#39;

# For testing - groups files into equal partitions a, b, c based on order of occurence in list
def TestGroup(files:list[File]):
    tot = len(files)
    group = defaultdict(list)
    for i in range(tot):
        if(i &lt; tot/3):
            group[&#34;a&#34;].append(files[i])
        elif(i&lt; 2*tot/3):
            group[&#34;b&#34;].append(files[i])
        else:
            group[&#34;c&#34;].append(files[i])
    return group

# Use to group files by type only (not subtypes) 
def GroupByType(files:list[File]):
    &#39;&#39;&#39; 
    Description
    -----------
    Group the list of files based on their extension Type tag. Returns a dict of extension type (tag name, e.g. &#34;Documents&#34;) -&gt; list of files of that type   
    
    Args:
    -----
        files : list[File or pathlike]
            #: The list of files to be grouped

    Outputs
    -------
        typeFilesDict: dict[str] = list[File]
            #: Dict with type tag name -&gt; list of files
    
    Notes:
    ------
    Since files only have the subtype tag attribute, the type tag is accessed using the subtypeTag.parentTag attribute.
    &#39;&#39;&#39;

    # File will have subtype defined in extensionSubtypeStr - use this to get parent type
    typeFilesDict = defaultdict(list)

    for file in files:
        # Get the subtype tag for this file
        subtypeTag = ParseTag(TAG_TREE.allTagsNameDict[file.extensionSubtypeStr])
        if(subtypeTag.tagName == &#34;Misc&#34;):
            # Misc tag has no parent type tag
            typeTag = subtypeTag
        else:
            # Get the parent tag for this subtype
            typeTag = subtypeTag.parentTag
        
        # Add the file to the dict
        typeFilesDict[typeTag.tagName].append(file)

    # Dict of group (type) -&gt; files in group
    return typeFilesDict

# Create nested groups of type -&gt; subtype -&gt; files
def GroupBySubtype(files:list[File]):
    &#39;&#39;&#39; 
    Description
    -----------
    Group the list of files based on their extension subtype tag. Returns a dict of extension subtype (tag name, e.g. &#34;Spreadsheet&#34;) -&gt; list of files of that subtype   
    
    Args:
    -----
        files : list[File or pathlike]
            #: The list of files to be grouped

    Outputs
    -------
        groupDict: dict[str] = list[File]
            #: Dict with subtype tag name -&gt; list of files
        
    &#39;&#39;&#39;
    typeSubtypeDict = TAG_TREE.typeSubtypeDict
    subtypeFilesDict = defaultdict(list)

    for file in files:
        subtype = file.extensionSubtypeStr
        subtypeFilesDict[subtype].append(file)
    
    # Dict of subtype -&gt; files  
    groupDict = dict()

    
    for subtypes in list(typeSubtypeDict.values()):
        for subtype in subtypes:
            subtypeFiles = subtypeFilesDict[subtype]
            if(len(subtypeFiles)&gt;0):
                groupDict[subtype] = subtypeFiles
    
    return groupDict


# Group based on a list of supplied keywords (fuzzily matched)
def GroupByKeyword(files:list[File], keywords:list[str]):
    &#39;&#39;&#39; 
    Description
    -----------
    Group the list of files based on the supplied list of keywords. Files are placed into a dataframe which is searched using the MultiTermFuzzySearch method.
    
    The matching files for each keyword are thus grouped - NOTE this does not yet account for the situation where a single file matches multiple keywords, which 
    would cause the file to be placed into multiple locations (not possible on filesystem).
    
    Files that are not matched to any keyword are placed into the &#34;Other&#34; group. If a supplied keyword is already named &#34;Other&#34;, the unmatched group is renamed to &#34;_Other&#34;.

    Returns a dict of keyword -&gt; list of files matching that keyword
    
    Args:
    -----
        files : list[File or pathlike]
            #: The list of files to be grouped
        keywords : list[str]
            #: The list of keyword strings to search for

    Outputs
    -------
        groupDict: dict[str] = list[File]
            #: Dict with keyword -&gt; list of matched files
        
    &#39;&#39;&#39;

    groupDict = defaultdict(list)

    # Create a searchable dataframe of files
    cols = (&#34;pathStr&#34;, &#34;name&#34;)
    rows = list()
    for file in files:
        file = ParseFobject(file)
        # Extract the desired keys into a dummy dict and add to file rows
        rows.append(dict((key, file.__dict__[key]) for key in cols))
    fileIndex = [row[&#34;pathStr&#34;] for row in rows]

    # Build the dataframe
    fileDf = pd.DataFrame(rows, index=fileIndex, dtype=&#34;string&#34;)

    # List for storing all matched results (to identify unmatched results)
    allMatchedResults = list()
    # Fuzzy search the dataframe for each keyword
    for keyword in keywords:
        searchTerms = FindSimilarSearchTerms(keyword)
        # Results are paths of matching files
        termResults, termResultsDict, resultTermsDict = MultiTermFuzzySearch(searchTerms, fileDf, &#39;name&#39;, uniqueOnly=False)
        allMatchedResults.extend(termResults)
        folderName = keyword.capitalize()
        groupDict[folderName] = [ParseFobject(result) for result in termResults]
    
    # Identify any files not matched and place into the &#34;Other&#34; group
    unmatchedFiles = list(set(fileIndex) - set(allMatchedResults))
    # Ensure no clash with already existing keyword
    if(&#34;Other&#34; in keywords):
        other = &#34;_Other&#34;
    else:
        other = &#34;Other&#34;
    # Add unmatched files into other group
    groupDict[other] = [ParseFobject(unmatched) for unmatched in unmatchedFiles]

    # Identify any files that were matched more than once
    multiMatches = list(unique_everseen(duplicates(allMatchedResults)))
    # Build dict of multi match result -&gt; matching terms
    multiMatchTermDict = {match:resultTermsDict[match] for match in multiMatches}


    return groupDict





# ======================================================== #
# ======================= GROUPING ======================= #
# ======================================================== #



# Object to hold grouper configuration: Group hierarchy and specific group vars like keywords 
class Grouper():
    &#34;&#34;&#34;
    Class:
    ------

    This class handles the grouping operations requested by the user. 
    It defines references to the possible grouping methods in the groupMethods dict (methods referenced by name, e.g GroupByType = &#34;Type&#34;)
    The class is constructed with the grouping order supplied from the interface, the desired destination of the grouped files and any keywords (if relevant).
    The first level of groups defined in the hierarchy will be created as subdirectories of the specified destination.
    
    &#34;&#34;&#34;
    
    def __init__(self, destination:Path, groupOrder:list[str], keywords=None):
        &#39;&#39;&#39; 
        Description
        -----------
        Constructor for the Grouper class. Takes the group order as a list of named grouping methods, the desired destination for the grouped files and any keywords if relevant.
        
        Args:
        -----
            destination : Path or pathlike
                #: The destination for the grouped files.
            groupOrder : list[str]
                #: The list of group names, first element is outermost group.
        Kwargs:
        -------    
            keywords : list[str] : default=None
                #: The list of keyword strings to search for.
            
        &#39;&#39;&#39;   
        
        # Methods that perform each grouping 
        self.groupMethods = {
            &#34;Type&#34;:GroupByType, 
            &#34;Subtype&#34;:GroupBySubtype, 
            &#34;Dummy&#34;:TestGroup, 
            &#34;Keyword&#34;:GroupByKeyword
        }
        # Destination for the group folders (first in hierarchy)
        self.destination = ParsePath(destination)
        # Grouping hierarchy
        self.groupOrder = groupOrder
        # Keywords (if required)
        if(keywords):
            self.keywords = keywords


        # ----- GROUPER RESULTS ---- #
        self.previewPathDict = dict()
        self.groupStructureDict = dict()


# Build the dict containing all nested groups 
def CreateAllNestedGroups(files:list[File], grouper:Grouper):
    &#39;&#39;&#39; 
    Description
    -----------
    Uses the defined hierarchy in the Grouper object to create a dict containing all nested groups. 
    
    The nested dict is of the form groupName -&gt; groupItems, where the groupItems may be more dicts containing further groups.  
    
    Args:
    -----
        files : list[File or pathlike]
            #: The list of files to be grouped
        grouper : Grouper
            #: The grouper object defining the hierarchy

    Outputs
    -------
        nestedGroupsDict : dict[str] = (dict[str] = list[File] ... or list[file] )
            #: Nested dict containing groupName -&gt; groupItemsDict
        
    &#39;&#39;&#39;
    # The first group in the hierarchy
    group = grouper.groupOrder[0]
    # Perform first grouping (recursion needs a dict with groups already to begin)
    if(group == &#34;Keyword&#34;):
        nestedGroupsDict = grouper.groupMethods[group](files, grouper.keywords)
    else:
        nestedGroupsDict = grouper.groupMethods[group](files)
    # Remove the first group before recursing
    grouper.groupOrder.remove(group)
    # Recursively perform the subgroupings
    for group in grouper.groupOrder:
        nestedGroupsDict = AppendNestedSubgroups(nestedGroupsDict, group, grouper)
    
    return nestedGroupsDict


# Recursively perform the subgrouping within the parent groups dict
def AppendNestedSubgroups(parentGroupsDict, subgroupName, grouper:Grouper):
    &#39;&#39;&#39; 
    Description
    -----------
    Uses the specified subgroupName to create the dict of grouped files for that particular subgroup, the result is appended to the previously constructed parentGroupsDict.
    
    The groupItems in the parentGroupsDict are either a list of files or dicts containing further groups. If they are files, this function performs the desired grouping on those files.
    If they are dicts, this function is then called recursively in order to create all nested subsubgroups within this particular subgroup, until files are found and thus grouped. 
   
    Args:
    -----
        parentGroupsDict : dict[str] = (dict[str] = list[File] ... or list[file] )
            #: The already constructed dict containing parent groups
        subgroupName : str
            #: The name of the subgroup at the current level in the hierarchy 
        grouper : Grouper
            #: The grouper object defining the hierarchy

    Outputs
    -------
        parentGroupsDict : dict[str] = (dict[str] = list[File] ... or list[file] )
            #: The already constructed dict containing parent groups and appended subgroup
        
    &#39;&#39;&#39;
    for parentGroup in parentGroupsDict:
        group = parentGroupsDict[parentGroup]
        # Check if list of files or more subgroup dicts (recurse if dicts until files found)
        if(isinstance(group, dict)):
            AppendNestedSubgroups(group, subgroupName)
        else:
            files = parentGroupsDict[parentGroup]
            # Perform the desired subgrouping
            if(group == &#34;Keyword&#34;):
                subgroupDict = grouper.groupMethods[subgroupName](files, grouper.keywords)
            else:
                subgroupDict = grouper.groupMethods[subgroupName](files)
            parentGroupsDict[parentGroup] = subgroupDict

    return parentGroupsDict


# Creates all folders for the nested groups
def CreateAllNestedFolders(nestedGroupsDict, grouper:Grouper):
    &#39;&#39;&#39; 
    Description
    -----------
    Uses the dict containing the nested groups to create empty folders for each group. 
    
    This step is completed before the user has verified changes, but no files are moved at this stage - only empty folders created.
    If the changes are not accepted these empty folders are removed.
    
    The proposed changes (new locations of grouped files) are stored in the grouper.previewPathDict object.
    The subgroup -&gt; parent group folder structure is stored in the grouper.groupStructureDict object (required for building jsTree instance)
       
    Args:
    -----
        nestedGroupsDict : dict[str] = (dict[str] = list[File] ... or list[file] )
            #: The dict containing nested groups
        grouper : Grouper
            #: The grouper object defining the hierarchy

        
    &#39;&#39;&#39;
    for group in list(nestedGroupsDict.keys()):
        grouper.previewPathDict, grouper.groupStructureDict = CreateNestedGroupFolders(group, nestedGroupsDict[group], grouper.destination, grouper.previewPathDict, grouper.groupStructureDict)



# Recursively creates each subgroup folder within a group 
def CreateNestedGroupFolders(groupName, groupItems, parent:Path, previewPathDict, groupStructureDict):
    &#39;&#39;&#39; 
    Description
    -----------
    Recursively created the subfolders for each subgroup within the specified group with groupName. 
    
    The groupItems are either a list of files or dicts containing further groups. If they are files, their new proposed locations are stored in the previewPathDict.
    If they are dicts, this function is then called recursively in order to create all nested subgroups within this particular group. 
   
    Args:
    -----
        groupName : str
            #: The name of the current group
        groupItems : dict[str] = (dict[str] = list[File] ... or list[file] ) or list[file]
            #: The items in the group - either more group dicts or a list of files
        parent : Path
            #: The path of the parent folder that will contain this subgroup folder
        previewPathDict : dict[Path] = list[File]
            #: The dict of Path -&gt; files proposed for this new location
        groupStructureDict : dict[Path] = Path
            #: The dict of subgroup Path -&gt; parent group Path

    Outputs
    -------
        previewPathDict : dict[Path] = list[File]
            #: The dict of Path -&gt; files proposed for this new location
        groupStructureDict : dict[Path] = Path
            #: The dict of subgroup Path -&gt; parent group Path
        
    &#39;&#39;&#39;
    # Make the path to the group folder 
    groupPath = ParsePath(parent) / groupName
    # Make the group directory
    os.mkdir(groupPath.absolute())

    # Add the group -&gt; parent to the structure dict
    groupStructureDict[groupPath] = ParsePath(parent)

    # Check if this group contains list of files or more subgroups (then recurse) 
    if(isinstance(groupItems, list)):
        # Group items simply contained list of files, add to group folder
        # Add the subgroup items to the proposed path dict
        previewPathDict[groupPath] = groupItems
    else:
        #Group items is a dict of subgroups - recurse 
        for subgroup in list(groupItems.keys()):
                CreateNestedGroupFolders(subgroup, groupItems[subgroup], groupPath, previewPathDict, groupStructureDict)

    return previewPathDict, groupStructureDict


# Build the preview of grouped files (for jsTree)
def BuildPreviewJsTreeJson(grouper:Grouper):
    &#39;&#39;&#39; 
    Description
    -----------
    Given the previewPathDict and groupStructureDicts within the Grouper object, this function creates the JSON strings required to build the preview jsTree instance.
       
    Args:
    -----
        grouper : Grouper
            #: The grouper object defining the hierarchy and storing grouping results
        
    Outputs:
    --------
        allJson : [str]
            #: String array containing all JSON strings for the preview instance
    &#39;&#39;&#39;

    parentJson = {
        &#34;id&#34;            : grouper.destination.as_posix(),
        &#34;parent&#34;        : &#39;#&#39;,
        &#34;icon&#34;          : &#39;fas fa-folder-open&#39;,
        &#34;text&#34;          : str(grouper.destination.name),
        &#34;a_attr&#34;        : {&#34;style&#34;:&#34;font-size:20px&#34;}
    }

    allJSON = list()
    allJSON.append(json.dumps(parentJson))
    
    # Build the group folder structure
    for groupParentPair in grouper.groupStructureDict.items():
        groupPath = ParsePath(groupParentPair[0])
        parentPath = ParsePath(groupParentPair[1])
        folderJson = {
        &#34;id&#34;            : groupPath.as_posix(),
        &#34;parent&#34;        : parentPath.as_posix(),
        &#34;icon&#34;          : &#39;fas fa-folder-open&#39;,
        &#34;text&#34;          : str(groupPath.name),
        &#34;a_attr&#34;        : {&#34;style&#34;:&#34;font-size:20px&#34;}
        }
        allJSON.append(json.dumps(folderJson))
    
    # Values are list of files in the subgroup (subgroups are keys)
    for groupFilesPair in grouper.previewPathDict.items():
        # Key is parent of group
        parent = ParsePath(groupFilesPair[0])
        # Value is list of files in group
        for file in groupFilesPair[1]:
            # The actual path to the file (where it is before moving)
            actualPath = ParsePath(file)
            proposedPath = parent / actualPath.name
            fileJson = {
                &#34;id&#34;            : proposedPath.as_posix(),
                &#34;parent&#34;        : parent.as_posix(),
                &#34;icon&#34;          : &#39;fas fa-file&#39;,
                &#34;text&#34;          : str(actualPath.name),
                &#34;a_attr&#34;        : {&#34;style&#34;:&#34;font-size:20px&#34;}
            }
            allJSON.append(json.dumps(fileJson))

    return allJSON



# Main function for building the preview for verification
def FileGrouperMain_Preview(groupOrder:list[str], includedFolders:list[Folder], destination:Path, keywords=None):
    &#39;&#39;&#39; 
    Description
    -----------
    The main function used to build the preview of the desired grouping. The group hierarchy is passed as a string list and used to construct the Grouper object for this grouping operation.

    All files within the includedFolders will be considered for grouping. No files will be moved until the user verifies the proposed changes.
       
    Args:
    -----
        groupOrder : list[str]
            #: The group order list (of group names) parsed from the user input
        includedFolders : list[Folder]
            #: List of folders within which files will be grouped
        destination : Path
            #: The destination for the groups
    Kwargs:
    -------
        keywords : list[str] : default=None
        
    Outputs:
    --------
        allJson : [str]
            #: String array containing all JSON strings for the preview instance
    &#39;&#39;&#39;
    # Create consecutive folder in destination
    destination = makeNewConsecutiveFolder(destination, &#34;InterfaceGroupTest&#34;)
    
    # Build the grouper object used to hold configuration
    grouper = Grouper(destination, groupOrder, keywords=keywords)
    
    # Get list of all files to be grouped
    allFiles = list()
    for folder in includedFolders:
        # If new folder was created after tree built ParseFobject would return None - ignore new folders (likely a new consecutive folder in the destination if the tree contained the destination)
        if(folder == None):
            continue
        # Add files in top level of included folder
        allFiles.extend(ListAllToplevelFiles(list({ParseFobject(folder)})))
        # Add all files in subdirs
        allFiles.extend(ListAllToplevelFiles([ParseFobject(subdir) for subdir in ListFolderContents(folder, allSubdirs=True) if ParseFobject(subdir) is not None]))
    
    # Create all nested groups
    nestedGroups = CreateAllNestedGroups(allFiles, grouper)
    # Create folders and assign files to proposed group folders (not moved yet)
    CreateAllNestedFolders(nestedGroups, grouper)
    # Build jstree json for preview of groups 
    previewJson = BuildPreviewJsTreeJson(grouper)

    return previewJson, grouper.previewPathDict, grouper.groupStructureDict


# Deletes (empty) folders created if not accepted - moves files and creates backup if changes accepted 
def FileGrouperMain_Verified(accepted:bool, destination, previewPathDict, groupStructureDict):
    &#39;&#39;&#39; 
    Description
    -----------
    The main function used to move files (or cancel) once the user has verified the changes.

    If the changes were not accepted the empty group folders previously created will be removed.

    This does not accept a grouper instance (since it is only local to the FileGrouperMain_Preview scope) but rather the destination path and dicts that were previously stored in the cache by the grouping_utility view.
       
    Args:
    -----
        accepted : bool
            #: True if the changes were accepted
        destination : Path
            #: The destination for the groups
                previewPathDict : dict[Path] = list[File]
            #: The dict of Path -&gt; files proposed for this new location
        groupStructureDict : dict[Path] = Path
            #: The dict of subgroup Path -&gt; parent group Path
    Kwargs:
    -------
        keywords : list[str] : default=None
        
    Outputs:
    --------
        allJson : [str]
            #: String array containing all JSON strings for the preview instance
    &#39;&#39;&#39;   
    if(not accepted):
        # Remove the empty folders created in the preview step - do not affect destination 
        for group in groupStructureDict:
            # Check if this folder actually exists (could have been deleted by parent deletion) and is not the destination folder 
            if(validPath(group) and group is not destination):
                # Delete folder and any subfolders - guaranteed to be empty folders - no files moved yet
                shutil.rmtree(group.as_posix())

    else:
        # Create the backup
        backupJson = CreateGrouperBackup(previewPathDict)

        # Perform the move
        MoveFilesIntoGroups(previewPathDict)

        # Return the backup to the view
        return backupJson


# ======================================================== #
# ==================== MOVING + BACKUP =================== #
# ======================================================== #
    

# Create a backup of the original locations for any files moved by the grouper
def CreateGrouperBackup(previewPathDict):
    &#39;&#39;&#39; 
    Description
    -----------
    Creates a backup of the original locations of the files to be grouped, by storing a dict (as JSON string) with new proposed location -&gt; old location. 

    This JSON string can additionaly be downloaded by the user and used to restore from backup at a later time after navigating away from the page.
       
    Args:
    -----
        previewPathDict : dict[File] = Path
            #: The dict with the proposed locations of the grouped files
        
    Outputs:
    --------
        backupJson : [str]
            #: JSON string serialising the backup dict
    &#39;&#39;&#39;
    # Stores new location -&gt; old location (as posix path strings)
    backupFileDict = dict()
    # Files in proposed path dict still have their original locations
    for groupFilesPair in previewPathDict.items():
        newLocationPath = groupFilesPair[0]
        # Pair has list of files in new group location
        for file in groupFilesPair[1]:
            oldLocation = file.path.as_posix()
            newLocation = Path(newLocationPath / file.path.name).as_posix()

            # Store the new -&gt; old locations (as posix path strings)
            backupFileDict[newLocation] = oldLocation

    # Store the backup in JSON
    backupJson = json.dumps(backupFileDict)
    
    return backupJson 


# Move any grouped files back to their original locations (providing no additional changes have been made to the grouped files)
def RestoreGroupedFilesFromBackup(backupJson):
    &#39;&#39;&#39; 
    Description
    -----------
    From the backup JSON string this will restore grouped files to their original locations.

    NOTE: Any subsequent changes to the new locations of the grouped files will thus be missed by such a backup, which only stores the locations immediately after grouping has been performed. 
       
    Args:
    -----
        backupJson : [str]
            #: JSON string serialising the backup dict

    &#39;&#39;&#39;
    backupDict = json.loads(backupJson)

    for newOldLocationPair in backupDict.items():
        # Where the file is now
        newLoc = newOldLocationPair[0]
        # Where the file should be moved back to
        oldLoc = newOldLocationPair[1]
        try:
            shutil.move(newLoc, oldLoc)
        except:
            print(&#34;Could not move file! #: &#34; + newLoc)


# Move the files into their respective groups (uses shutil to allow for moving between disks)
def MoveFilesIntoGroups(previewPathDict):
    &#39;&#39;&#39; 
    Description
    -----------
    This function moves files from their original locations to the newly proposed grouped locations, once the user has accepted the changes to be made.
       
    Args:
    -----
        previewPathDict : dict[File] = Path
            #: The dict with the proposed locations of the grouped files
    &#39;&#39;&#39;
    for groupFilesPair in previewPathDict.items():
        # Group folder
        destination = groupFilesPair[0]
        for file in groupFilesPair[1]:
            # Target location for the moved file
            newFilePath = destination / file.path.name
            try:
                shutil.move(file.path.as_posix(), newFilePath.as_posix())
            except:
                print(&#34;Could not move file! #: &#34; + file.path.as_posix())</code></pre>
</details>
</section>
<section>
</section>

<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="grouper.AppendNestedSubgroups"><code class="name flex">
<span>def <span class="ident">AppendNestedSubgroups</span></span>(<span>parentGroupsDict, subgroupName, grouper: <a title="grouper.Grouper" href="#grouper.Grouper">Grouper</a>)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Uses the specified subgroupName to create the dict of grouped files for that particular subgroup, the result is appended to the previously constructed parentGroupsDict.</p>
<p>The groupItems in the parentGroupsDict are either a list of files or dicts containing further groups. If they are files, this function performs the desired grouping on those files.
If they are dicts, this function is then called recursively in order to create all nested subsubgroups within this particular subgroup, until files are found and thus grouped. </p>
<h2 id="args">Args:</h2>
<pre><code>parentGroupsDict : dict[str] = (dict[str] = list[File] ... or list[file] )
    #: The already constructed dict containing parent groups
subgroupName : str
    #: The name of the subgroup at the current level in the hierarchy 
grouper : Grouper
    #: The grouper object defining the hierarchy
</code></pre>
<h2 id="outputs">Outputs</h2>
<pre><code>parentGroupsDict : dict[str] = (dict[str] = list[File] ... or list[file] )
    #: The already constructed dict containing parent groups and appended subgroup
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AppendNestedSubgroups(parentGroupsDict, subgroupName, grouper:Grouper):
    &#39;&#39;&#39; 
    Description
    -----------
    Uses the specified subgroupName to create the dict of grouped files for that particular subgroup, the result is appended to the previously constructed parentGroupsDict.
    
    The groupItems in the parentGroupsDict are either a list of files or dicts containing further groups. If they are files, this function performs the desired grouping on those files.
    If they are dicts, this function is then called recursively in order to create all nested subsubgroups within this particular subgroup, until files are found and thus grouped. 
   
    Args:
    -----
        parentGroupsDict : dict[str] = (dict[str] = list[File] ... or list[file] )
            #: The already constructed dict containing parent groups
        subgroupName : str
            #: The name of the subgroup at the current level in the hierarchy 
        grouper : Grouper
            #: The grouper object defining the hierarchy

    Outputs
    -------
        parentGroupsDict : dict[str] = (dict[str] = list[File] ... or list[file] )
            #: The already constructed dict containing parent groups and appended subgroup
        
    &#39;&#39;&#39;
    for parentGroup in parentGroupsDict:
        group = parentGroupsDict[parentGroup]
        # Check if list of files or more subgroup dicts (recurse if dicts until files found)
        if(isinstance(group, dict)):
            AppendNestedSubgroups(group, subgroupName)
        else:
            files = parentGroupsDict[parentGroup]
            # Perform the desired subgrouping
            if(group == &#34;Keyword&#34;):
                subgroupDict = grouper.groupMethods[subgroupName](files, grouper.keywords)
            else:
                subgroupDict = grouper.groupMethods[subgroupName](files)
            parentGroupsDict[parentGroup] = subgroupDict

    return parentGroupsDict</code></pre>
</details>
</dd>
<dt id="grouper.BuildPreviewJsTreeJson"><code class="name flex">
<span>def <span class="ident">BuildPreviewJsTreeJson</span></span>(<span>grouper: <a title="grouper.Grouper" href="#grouper.Grouper">Grouper</a>)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Given the previewPathDict and groupStructureDicts within the Grouper object, this function creates the JSON strings required to build the preview jsTree instance.</p>
<h2 id="args">Args:</h2>
<pre><code>grouper : Grouper
    #: The grouper object defining the hierarchy and storing grouping results
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>allJson : [str]
    #: String array containing all JSON strings for the preview instance
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BuildPreviewJsTreeJson(grouper:Grouper):
    &#39;&#39;&#39; 
    Description
    -----------
    Given the previewPathDict and groupStructureDicts within the Grouper object, this function creates the JSON strings required to build the preview jsTree instance.
       
    Args:
    -----
        grouper : Grouper
            #: The grouper object defining the hierarchy and storing grouping results
        
    Outputs:
    --------
        allJson : [str]
            #: String array containing all JSON strings for the preview instance
    &#39;&#39;&#39;

    parentJson = {
        &#34;id&#34;            : grouper.destination.as_posix(),
        &#34;parent&#34;        : &#39;#&#39;,
        &#34;icon&#34;          : &#39;fas fa-folder-open&#39;,
        &#34;text&#34;          : str(grouper.destination.name),
        &#34;a_attr&#34;        : {&#34;style&#34;:&#34;font-size:20px&#34;}
    }

    allJSON = list()
    allJSON.append(json.dumps(parentJson))
    
    # Build the group folder structure
    for groupParentPair in grouper.groupStructureDict.items():
        groupPath = ParsePath(groupParentPair[0])
        parentPath = ParsePath(groupParentPair[1])
        folderJson = {
        &#34;id&#34;            : groupPath.as_posix(),
        &#34;parent&#34;        : parentPath.as_posix(),
        &#34;icon&#34;          : &#39;fas fa-folder-open&#39;,
        &#34;text&#34;          : str(groupPath.name),
        &#34;a_attr&#34;        : {&#34;style&#34;:&#34;font-size:20px&#34;}
        }
        allJSON.append(json.dumps(folderJson))
    
    # Values are list of files in the subgroup (subgroups are keys)
    for groupFilesPair in grouper.previewPathDict.items():
        # Key is parent of group
        parent = ParsePath(groupFilesPair[0])
        # Value is list of files in group
        for file in groupFilesPair[1]:
            # The actual path to the file (where it is before moving)
            actualPath = ParsePath(file)
            proposedPath = parent / actualPath.name
            fileJson = {
                &#34;id&#34;            : proposedPath.as_posix(),
                &#34;parent&#34;        : parent.as_posix(),
                &#34;icon&#34;          : &#39;fas fa-file&#39;,
                &#34;text&#34;          : str(actualPath.name),
                &#34;a_attr&#34;        : {&#34;style&#34;:&#34;font-size:20px&#34;}
            }
            allJSON.append(json.dumps(fileJson))

    return allJSON</code></pre>
</details>
</dd>
<dt id="grouper.CreateAllNestedFolders"><code class="name flex">
<span>def <span class="ident">CreateAllNestedFolders</span></span>(<span>nestedGroupsDict, grouper: <a title="grouper.Grouper" href="#grouper.Grouper">Grouper</a>)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Uses the dict containing the nested groups to create empty folders for each group. </p>
<p>This step is completed before the user has verified changes, but no files are moved at this stage - only empty folders created.
If the changes are not accepted these empty folders are removed.</p>
<p>The proposed changes (new locations of grouped files) are stored in the grouper.previewPathDict object.
The subgroup -&gt; parent group folder structure is stored in the grouper.groupStructureDict object (required for building jsTree instance)</p>
<h2 id="args">Args:</h2>
<pre><code>nestedGroupsDict : dict[str] = (dict[str] = list[File] ... or list[file] )
    #: The dict containing nested groups
grouper : Grouper
    #: The grouper object defining the hierarchy
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CreateAllNestedFolders(nestedGroupsDict, grouper:Grouper):
    &#39;&#39;&#39; 
    Description
    -----------
    Uses the dict containing the nested groups to create empty folders for each group. 
    
    This step is completed before the user has verified changes, but no files are moved at this stage - only empty folders created.
    If the changes are not accepted these empty folders are removed.
    
    The proposed changes (new locations of grouped files) are stored in the grouper.previewPathDict object.
    The subgroup -&gt; parent group folder structure is stored in the grouper.groupStructureDict object (required for building jsTree instance)
       
    Args:
    -----
        nestedGroupsDict : dict[str] = (dict[str] = list[File] ... or list[file] )
            #: The dict containing nested groups
        grouper : Grouper
            #: The grouper object defining the hierarchy

        
    &#39;&#39;&#39;
    for group in list(nestedGroupsDict.keys()):
        grouper.previewPathDict, grouper.groupStructureDict = CreateNestedGroupFolders(group, nestedGroupsDict[group], grouper.destination, grouper.previewPathDict, grouper.groupStructureDict)</code></pre>
</details>
</dd>
<dt id="grouper.CreateAllNestedGroups"><code class="name flex">
<span>def <span class="ident">CreateAllNestedGroups</span></span>(<span>files: list, grouper: <a title="grouper.Grouper" href="#grouper.Grouper">Grouper</a>)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Uses the defined hierarchy in the Grouper object to create a dict containing all nested groups. </p>
<p>The nested dict is of the form groupName -&gt; groupItems, where the groupItems may be more dicts containing further groups.
</p>
<h2 id="args">Args:</h2>
<pre><code>files : list[File or pathlike]
    #: The list of files to be grouped
grouper : Grouper
    #: The grouper object defining the hierarchy
</code></pre>
<h2 id="outputs">Outputs</h2>
<pre><code>nestedGroupsDict : dict[str] = (dict[str] = list[File] ... or list[file] )
    #: Nested dict containing groupName -&gt; groupItemsDict
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CreateAllNestedGroups(files:list[File], grouper:Grouper):
    &#39;&#39;&#39; 
    Description
    -----------
    Uses the defined hierarchy in the Grouper object to create a dict containing all nested groups. 
    
    The nested dict is of the form groupName -&gt; groupItems, where the groupItems may be more dicts containing further groups.  
    
    Args:
    -----
        files : list[File or pathlike]
            #: The list of files to be grouped
        grouper : Grouper
            #: The grouper object defining the hierarchy

    Outputs
    -------
        nestedGroupsDict : dict[str] = (dict[str] = list[File] ... or list[file] )
            #: Nested dict containing groupName -&gt; groupItemsDict
        
    &#39;&#39;&#39;
    # The first group in the hierarchy
    group = grouper.groupOrder[0]
    # Perform first grouping (recursion needs a dict with groups already to begin)
    if(group == &#34;Keyword&#34;):
        nestedGroupsDict = grouper.groupMethods[group](files, grouper.keywords)
    else:
        nestedGroupsDict = grouper.groupMethods[group](files)
    # Remove the first group before recursing
    grouper.groupOrder.remove(group)
    # Recursively perform the subgroupings
    for group in grouper.groupOrder:
        nestedGroupsDict = AppendNestedSubgroups(nestedGroupsDict, group, grouper)
    
    return nestedGroupsDict</code></pre>
</details>
</dd>
<dt id="grouper.CreateGrouperBackup"><code class="name flex">
<span>def <span class="ident">CreateGrouperBackup</span></span>(<span>previewPathDict)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Creates a backup of the original locations of the files to be grouped, by storing a dict (as JSON string) with new proposed location -&gt; old location. </p>
<p>This JSON string can additionaly be downloaded by the user and used to restore from backup at a later time after navigating away from the page.</p>
<h2 id="args">Args:</h2>
<pre><code>previewPathDict : dict[File] = Path
    #: The dict with the proposed locations of the grouped files
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>backupJson : [str]
    #: JSON string serialising the backup dict
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CreateGrouperBackup(previewPathDict):
    &#39;&#39;&#39; 
    Description
    -----------
    Creates a backup of the original locations of the files to be grouped, by storing a dict (as JSON string) with new proposed location -&gt; old location. 

    This JSON string can additionaly be downloaded by the user and used to restore from backup at a later time after navigating away from the page.
       
    Args:
    -----
        previewPathDict : dict[File] = Path
            #: The dict with the proposed locations of the grouped files
        
    Outputs:
    --------
        backupJson : [str]
            #: JSON string serialising the backup dict
    &#39;&#39;&#39;
    # Stores new location -&gt; old location (as posix path strings)
    backupFileDict = dict()
    # Files in proposed path dict still have their original locations
    for groupFilesPair in previewPathDict.items():
        newLocationPath = groupFilesPair[0]
        # Pair has list of files in new group location
        for file in groupFilesPair[1]:
            oldLocation = file.path.as_posix()
            newLocation = Path(newLocationPath / file.path.name).as_posix()

            # Store the new -&gt; old locations (as posix path strings)
            backupFileDict[newLocation] = oldLocation

    # Store the backup in JSON
    backupJson = json.dumps(backupFileDict)
    
    return backupJson </code></pre>
</details>
</dd>
<dt id="grouper.CreateNestedGroupFolders"><code class="name flex">
<span>def <span class="ident">CreateNestedGroupFolders</span></span>(<span>groupName, groupItems, parent: pathlib.Path, previewPathDict, groupStructureDict)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Recursively created the subfolders for each subgroup within the specified group with groupName. </p>
<p>The groupItems are either a list of files or dicts containing further groups. If they are files, their new proposed locations are stored in the previewPathDict.
If they are dicts, this function is then called recursively in order to create all nested subgroups within this particular group. </p>
<h2 id="args">Args:</h2>
<pre><code>groupName : str
    #: The name of the current group
groupItems : dict[str] = (dict[str] = list[File] ... or list[file] ) or list[file]
    #: The items in the group - either more group dicts or a list of files
parent : Path
    #: The path of the parent folder that will contain this subgroup folder
previewPathDict : dict[Path] = list[File]
    #: The dict of Path -&gt; files proposed for this new location
groupStructureDict : dict[Path] = Path
    #: The dict of subgroup Path -&gt; parent group Path
</code></pre>
<h2 id="outputs">Outputs</h2>
<pre><code>previewPathDict : dict[Path] = list[File]
    #: The dict of Path -&gt; files proposed for this new location
groupStructureDict : dict[Path] = Path
    #: The dict of subgroup Path -&gt; parent group Path
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CreateNestedGroupFolders(groupName, groupItems, parent:Path, previewPathDict, groupStructureDict):
    &#39;&#39;&#39; 
    Description
    -----------
    Recursively created the subfolders for each subgroup within the specified group with groupName. 
    
    The groupItems are either a list of files or dicts containing further groups. If they are files, their new proposed locations are stored in the previewPathDict.
    If they are dicts, this function is then called recursively in order to create all nested subgroups within this particular group. 
   
    Args:
    -----
        groupName : str
            #: The name of the current group
        groupItems : dict[str] = (dict[str] = list[File] ... or list[file] ) or list[file]
            #: The items in the group - either more group dicts or a list of files
        parent : Path
            #: The path of the parent folder that will contain this subgroup folder
        previewPathDict : dict[Path] = list[File]
            #: The dict of Path -&gt; files proposed for this new location
        groupStructureDict : dict[Path] = Path
            #: The dict of subgroup Path -&gt; parent group Path

    Outputs
    -------
        previewPathDict : dict[Path] = list[File]
            #: The dict of Path -&gt; files proposed for this new location
        groupStructureDict : dict[Path] = Path
            #: The dict of subgroup Path -&gt; parent group Path
        
    &#39;&#39;&#39;
    # Make the path to the group folder 
    groupPath = ParsePath(parent) / groupName
    # Make the group directory
    os.mkdir(groupPath.absolute())

    # Add the group -&gt; parent to the structure dict
    groupStructureDict[groupPath] = ParsePath(parent)

    # Check if this group contains list of files or more subgroups (then recurse) 
    if(isinstance(groupItems, list)):
        # Group items simply contained list of files, add to group folder
        # Add the subgroup items to the proposed path dict
        previewPathDict[groupPath] = groupItems
    else:
        #Group items is a dict of subgroups - recurse 
        for subgroup in list(groupItems.keys()):
                CreateNestedGroupFolders(subgroup, groupItems[subgroup], groupPath, previewPathDict, groupStructureDict)

    return previewPathDict, groupStructureDict</code></pre>
</details>
</dd>
<dt id="grouper.FileGrouperMain_Preview"><code class="name flex">
<span>def <span class="ident">FileGrouperMain_Preview</span></span>(<span>groupOrder: list, includedFolders: list, destination: pathlib.Path, keywords=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>The main function used to build the preview of the desired grouping. The group hierarchy is passed as a string list and used to construct the Grouper object for this grouping operation.</p>
<p>All files within the includedFolders will be considered for grouping. No files will be moved until the user verifies the proposed changes.</p>
<h2 id="args">Args:</h2>
<pre><code>groupOrder : list[str]
    #: The group order list (of group names) parsed from the user input
includedFolders : list[Folder]
    #: List of folders within which files will be grouped
destination : Path
    #: The destination for the groups
</code></pre>
<h2 id="kwargs">Kwargs:</h2>
<pre><code>keywords : list[str] : default=None
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>allJson : [str]
    #: String array containing all JSON strings for the preview instance
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FileGrouperMain_Preview(groupOrder:list[str], includedFolders:list[Folder], destination:Path, keywords=None):
    &#39;&#39;&#39; 
    Description
    -----------
    The main function used to build the preview of the desired grouping. The group hierarchy is passed as a string list and used to construct the Grouper object for this grouping operation.

    All files within the includedFolders will be considered for grouping. No files will be moved until the user verifies the proposed changes.
       
    Args:
    -----
        groupOrder : list[str]
            #: The group order list (of group names) parsed from the user input
        includedFolders : list[Folder]
            #: List of folders within which files will be grouped
        destination : Path
            #: The destination for the groups
    Kwargs:
    -------
        keywords : list[str] : default=None
        
    Outputs:
    --------
        allJson : [str]
            #: String array containing all JSON strings for the preview instance
    &#39;&#39;&#39;
    # Create consecutive folder in destination
    destination = makeNewConsecutiveFolder(destination, &#34;InterfaceGroupTest&#34;)
    
    # Build the grouper object used to hold configuration
    grouper = Grouper(destination, groupOrder, keywords=keywords)
    
    # Get list of all files to be grouped
    allFiles = list()
    for folder in includedFolders:
        # If new folder was created after tree built ParseFobject would return None - ignore new folders (likely a new consecutive folder in the destination if the tree contained the destination)
        if(folder == None):
            continue
        # Add files in top level of included folder
        allFiles.extend(ListAllToplevelFiles(list({ParseFobject(folder)})))
        # Add all files in subdirs
        allFiles.extend(ListAllToplevelFiles([ParseFobject(subdir) for subdir in ListFolderContents(folder, allSubdirs=True) if ParseFobject(subdir) is not None]))
    
    # Create all nested groups
    nestedGroups = CreateAllNestedGroups(allFiles, grouper)
    # Create folders and assign files to proposed group folders (not moved yet)
    CreateAllNestedFolders(nestedGroups, grouper)
    # Build jstree json for preview of groups 
    previewJson = BuildPreviewJsTreeJson(grouper)

    return previewJson, grouper.previewPathDict, grouper.groupStructureDict</code></pre>
</details>
</dd>
<dt id="grouper.FileGrouperMain_Verified"><code class="name flex">
<span>def <span class="ident">FileGrouperMain_Verified</span></span>(<span>accepted: bool, destination, previewPathDict, groupStructureDict)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>The main function used to move files (or cancel) once the user has verified the changes.</p>
<p>If the changes were not accepted the empty group folders previously created will be removed.</p>
<p>This does not accept a grouper instance (since it is only local to the FileGrouperMain_Preview scope) but rather the destination path and dicts that were previously stored in the cache by the grouping_utility view.</p>
<h2 id="args">Args:</h2>
<pre><code>accepted : bool
    #: True if the changes were accepted
destination : Path
    #: The destination for the groups
        previewPathDict : dict[Path] = list[File]
    #: The dict of Path -&gt; files proposed for this new location
groupStructureDict : dict[Path] = Path
    #: The dict of subgroup Path -&gt; parent group Path
</code></pre>
<h2 id="kwargs">Kwargs:</h2>
<pre><code>keywords : list[str] : default=None
</code></pre>
<h2 id="outputs">Outputs:</h2>
<pre><code>allJson : [str]
    #: String array containing all JSON strings for the preview instance
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FileGrouperMain_Verified(accepted:bool, destination, previewPathDict, groupStructureDict):
    &#39;&#39;&#39; 
    Description
    -----------
    The main function used to move files (or cancel) once the user has verified the changes.

    If the changes were not accepted the empty group folders previously created will be removed.

    This does not accept a grouper instance (since it is only local to the FileGrouperMain_Preview scope) but rather the destination path and dicts that were previously stored in the cache by the grouping_utility view.
       
    Args:
    -----
        accepted : bool
            #: True if the changes were accepted
        destination : Path
            #: The destination for the groups
                previewPathDict : dict[Path] = list[File]
            #: The dict of Path -&gt; files proposed for this new location
        groupStructureDict : dict[Path] = Path
            #: The dict of subgroup Path -&gt; parent group Path
    Kwargs:
    -------
        keywords : list[str] : default=None
        
    Outputs:
    --------
        allJson : [str]
            #: String array containing all JSON strings for the preview instance
    &#39;&#39;&#39;   
    if(not accepted):
        # Remove the empty folders created in the preview step - do not affect destination 
        for group in groupStructureDict:
            # Check if this folder actually exists (could have been deleted by parent deletion) and is not the destination folder 
            if(validPath(group) and group is not destination):
                # Delete folder and any subfolders - guaranteed to be empty folders - no files moved yet
                shutil.rmtree(group.as_posix())

    else:
        # Create the backup
        backupJson = CreateGrouperBackup(previewPathDict)

        # Perform the move
        MoveFilesIntoGroups(previewPathDict)

        # Return the backup to the view
        return backupJson</code></pre>
</details>
</dd>
<dt id="grouper.GroupByKeyword"><code class="name flex">
<span>def <span class="ident">GroupByKeyword</span></span>(<span>files: list, keywords: list)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Group the list of files based on the supplied list of keywords. Files are placed into a dataframe which is searched using the MultiTermFuzzySearch method.</p>
<p>The matching files for each keyword are thus grouped - NOTE this does not yet account for the situation where a single file matches multiple keywords, which
would cause the file to be placed into multiple locations (not possible on filesystem).</p>
<p>Files that are not matched to any keyword are placed into the "Other" group. If a supplied keyword is already named "Other", the unmatched group is renamed to "_Other".</p>
<p>Returns a dict of keyword -&gt; list of files matching that keyword</p>
<h2 id="args">Args:</h2>
<pre><code>files : list[File or pathlike]
    #: The list of files to be grouped
keywords : list[str]
    #: The list of keyword strings to search for
</code></pre>
<h2 id="outputs">Outputs</h2>
<pre><code>groupDict: dict[str] = list[File]
    #: Dict with keyword -&gt; list of matched files
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GroupByKeyword(files:list[File], keywords:list[str]):
    &#39;&#39;&#39; 
    Description
    -----------
    Group the list of files based on the supplied list of keywords. Files are placed into a dataframe which is searched using the MultiTermFuzzySearch method.
    
    The matching files for each keyword are thus grouped - NOTE this does not yet account for the situation where a single file matches multiple keywords, which 
    would cause the file to be placed into multiple locations (not possible on filesystem).
    
    Files that are not matched to any keyword are placed into the &#34;Other&#34; group. If a supplied keyword is already named &#34;Other&#34;, the unmatched group is renamed to &#34;_Other&#34;.

    Returns a dict of keyword -&gt; list of files matching that keyword
    
    Args:
    -----
        files : list[File or pathlike]
            #: The list of files to be grouped
        keywords : list[str]
            #: The list of keyword strings to search for

    Outputs
    -------
        groupDict: dict[str] = list[File]
            #: Dict with keyword -&gt; list of matched files
        
    &#39;&#39;&#39;

    groupDict = defaultdict(list)

    # Create a searchable dataframe of files
    cols = (&#34;pathStr&#34;, &#34;name&#34;)
    rows = list()
    for file in files:
        file = ParseFobject(file)
        # Extract the desired keys into a dummy dict and add to file rows
        rows.append(dict((key, file.__dict__[key]) for key in cols))
    fileIndex = [row[&#34;pathStr&#34;] for row in rows]

    # Build the dataframe
    fileDf = pd.DataFrame(rows, index=fileIndex, dtype=&#34;string&#34;)

    # List for storing all matched results (to identify unmatched results)
    allMatchedResults = list()
    # Fuzzy search the dataframe for each keyword
    for keyword in keywords:
        searchTerms = FindSimilarSearchTerms(keyword)
        # Results are paths of matching files
        termResults, termResultsDict, resultTermsDict = MultiTermFuzzySearch(searchTerms, fileDf, &#39;name&#39;, uniqueOnly=False)
        allMatchedResults.extend(termResults)
        folderName = keyword.capitalize()
        groupDict[folderName] = [ParseFobject(result) for result in termResults]
    
    # Identify any files not matched and place into the &#34;Other&#34; group
    unmatchedFiles = list(set(fileIndex) - set(allMatchedResults))
    # Ensure no clash with already existing keyword
    if(&#34;Other&#34; in keywords):
        other = &#34;_Other&#34;
    else:
        other = &#34;Other&#34;
    # Add unmatched files into other group
    groupDict[other] = [ParseFobject(unmatched) for unmatched in unmatchedFiles]

    # Identify any files that were matched more than once
    multiMatches = list(unique_everseen(duplicates(allMatchedResults)))
    # Build dict of multi match result -&gt; matching terms
    multiMatchTermDict = {match:resultTermsDict[match] for match in multiMatches}


    return groupDict</code></pre>
</details>
</dd>
<dt id="grouper.GroupBySubtype"><code class="name flex">
<span>def <span class="ident">GroupBySubtype</span></span>(<span>files: list)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Group the list of files based on their extension subtype tag. Returns a dict of extension subtype (tag name, e.g. "Spreadsheet") -&gt; list of files of that subtype
</p>
<h2 id="args">Args:</h2>
<pre><code>files : list[File or pathlike]
    #: The list of files to be grouped
</code></pre>
<h2 id="outputs">Outputs</h2>
<pre><code>groupDict: dict[str] = list[File]
    #: Dict with subtype tag name -&gt; list of files
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GroupBySubtype(files:list[File]):
    &#39;&#39;&#39; 
    Description
    -----------
    Group the list of files based on their extension subtype tag. Returns a dict of extension subtype (tag name, e.g. &#34;Spreadsheet&#34;) -&gt; list of files of that subtype   
    
    Args:
    -----
        files : list[File or pathlike]
            #: The list of files to be grouped

    Outputs
    -------
        groupDict: dict[str] = list[File]
            #: Dict with subtype tag name -&gt; list of files
        
    &#39;&#39;&#39;
    typeSubtypeDict = TAG_TREE.typeSubtypeDict
    subtypeFilesDict = defaultdict(list)

    for file in files:
        subtype = file.extensionSubtypeStr
        subtypeFilesDict[subtype].append(file)
    
    # Dict of subtype -&gt; files  
    groupDict = dict()

    
    for subtypes in list(typeSubtypeDict.values()):
        for subtype in subtypes:
            subtypeFiles = subtypeFilesDict[subtype]
            if(len(subtypeFiles)&gt;0):
                groupDict[subtype] = subtypeFiles
    
    return groupDict</code></pre>
</details>
</dd>
<dt id="grouper.GroupByType"><code class="name flex">
<span>def <span class="ident">GroupByType</span></span>(<span>files: list)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Group the list of files based on their extension Type tag. Returns a dict of extension type (tag name, e.g. "Documents") -&gt; list of files of that type
</p>
<h2 id="args">Args:</h2>
<pre><code>files : list[File or pathlike]
    #: The list of files to be grouped
</code></pre>
<h2 id="outputs">Outputs</h2>
<pre><code>typeFilesDict: dict[str] = list[File]
    #: Dict with type tag name -&gt; list of files
</code></pre>
<h2 id="notes">Notes:</h2>
<p>Since files only have the subtype tag attribute, the type tag is accessed using the subtypeTag.parentTag attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GroupByType(files:list[File]):
    &#39;&#39;&#39; 
    Description
    -----------
    Group the list of files based on their extension Type tag. Returns a dict of extension type (tag name, e.g. &#34;Documents&#34;) -&gt; list of files of that type   
    
    Args:
    -----
        files : list[File or pathlike]
            #: The list of files to be grouped

    Outputs
    -------
        typeFilesDict: dict[str] = list[File]
            #: Dict with type tag name -&gt; list of files
    
    Notes:
    ------
    Since files only have the subtype tag attribute, the type tag is accessed using the subtypeTag.parentTag attribute.
    &#39;&#39;&#39;

    # File will have subtype defined in extensionSubtypeStr - use this to get parent type
    typeFilesDict = defaultdict(list)

    for file in files:
        # Get the subtype tag for this file
        subtypeTag = ParseTag(TAG_TREE.allTagsNameDict[file.extensionSubtypeStr])
        if(subtypeTag.tagName == &#34;Misc&#34;):
            # Misc tag has no parent type tag
            typeTag = subtypeTag
        else:
            # Get the parent tag for this subtype
            typeTag = subtypeTag.parentTag
        
        # Add the file to the dict
        typeFilesDict[typeTag.tagName].append(file)

    # Dict of group (type) -&gt; files in group
    return typeFilesDict</code></pre>
</details>
</dd>
<dt id="grouper.MoveFilesIntoGroups"><code class="name flex">
<span>def <span class="ident">MoveFilesIntoGroups</span></span>(<span>previewPathDict)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>This function moves files from their original locations to the newly proposed grouped locations, once the user has accepted the changes to be made.</p>
<h2 id="args">Args:</h2>
<pre><code>previewPathDict : dict[File] = Path
    #: The dict with the proposed locations of the grouped files
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MoveFilesIntoGroups(previewPathDict):
    &#39;&#39;&#39; 
    Description
    -----------
    This function moves files from their original locations to the newly proposed grouped locations, once the user has accepted the changes to be made.
       
    Args:
    -----
        previewPathDict : dict[File] = Path
            #: The dict with the proposed locations of the grouped files
    &#39;&#39;&#39;
    for groupFilesPair in previewPathDict.items():
        # Group folder
        destination = groupFilesPair[0]
        for file in groupFilesPair[1]:
            # Target location for the moved file
            newFilePath = destination / file.path.name
            try:
                shutil.move(file.path.as_posix(), newFilePath.as_posix())
            except:
                print(&#34;Could not move file! #: &#34; + file.path.as_posix())</code></pre>
</details>
</dd>
<dt id="grouper.RestoreGroupedFilesFromBackup"><code class="name flex">
<span>def <span class="ident">RestoreGroupedFilesFromBackup</span></span>(<span>backupJson)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>From the backup JSON string this will restore grouped files to their original locations.</p>
<p>NOTE: Any subsequent changes to the new locations of the grouped files will thus be missed by such a backup, which only stores the locations immediately after grouping has been performed. </p>
<h2 id="args">Args:</h2>
<pre><code>backupJson : [str]
    #: JSON string serialising the backup dict
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RestoreGroupedFilesFromBackup(backupJson):
    &#39;&#39;&#39; 
    Description
    -----------
    From the backup JSON string this will restore grouped files to their original locations.

    NOTE: Any subsequent changes to the new locations of the grouped files will thus be missed by such a backup, which only stores the locations immediately after grouping has been performed. 
       
    Args:
    -----
        backupJson : [str]
            #: JSON string serialising the backup dict

    &#39;&#39;&#39;
    backupDict = json.loads(backupJson)

    for newOldLocationPair in backupDict.items():
        # Where the file is now
        newLoc = newOldLocationPair[0]
        # Where the file should be moved back to
        oldLoc = newOldLocationPair[1]
        try:
            shutil.move(newLoc, oldLoc)
        except:
            print(&#34;Could not move file! #: &#34; + newLoc)</code></pre>
</details>
</dd>
<dt id="grouper.TestGroup"><code class="name flex">
<span>def <span class="ident">TestGroup</span></span>(<span>files: list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TestGroup(files:list[File]):
    tot = len(files)
    group = defaultdict(list)
    for i in range(tot):
        if(i &lt; tot/3):
            group[&#34;a&#34;].append(files[i])
        elif(i&lt; 2*tot/3):
            group[&#34;b&#34;].append(files[i])
        else:
            group[&#34;c&#34;].append(files[i])
    return group</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="grouper.Grouper"><code class="flex name class">
<span>class <span class="ident">Grouper</span></span>
<span>(</span><span>destination: pathlib.Path, groupOrder: list, keywords=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="class">Class:</h2>
<p>This class handles the grouping operations requested by the user.
It defines references to the possible grouping methods in the groupMethods dict (methods referenced by name, e.g GroupByType = "Type")
The class is constructed with the grouping order supplied from the interface, the desired destination of the grouped files and any keywords (if relevant).
The first level of groups defined in the hierarchy will be created as subdirectories of the specified destination.</p>
<h2 id="description">Description</h2>
<p>Constructor for the Grouper class. Takes the group order as a list of named grouping methods, the desired destination for the grouped files and any keywords if relevant.</p>
<h2 id="args">Args:</h2>
<pre><code>destination : Path or pathlike
    #: The destination for the grouped files.
groupOrder : list[str]
    #: The list of group names, first element is outermost group.
</code></pre>
<h2 id="kwargs">Kwargs:</h2>
<pre><code>keywords : list[str] : default=None
    #: The list of keyword strings to search for.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grouper():
    &#34;&#34;&#34;
    Class:
    ------

    This class handles the grouping operations requested by the user. 
    It defines references to the possible grouping methods in the groupMethods dict (methods referenced by name, e.g GroupByType = &#34;Type&#34;)
    The class is constructed with the grouping order supplied from the interface, the desired destination of the grouped files and any keywords (if relevant).
    The first level of groups defined in the hierarchy will be created as subdirectories of the specified destination.
    
    &#34;&#34;&#34;
    
    def __init__(self, destination:Path, groupOrder:list[str], keywords=None):
        &#39;&#39;&#39; 
        Description
        -----------
        Constructor for the Grouper class. Takes the group order as a list of named grouping methods, the desired destination for the grouped files and any keywords if relevant.
        
        Args:
        -----
            destination : Path or pathlike
                #: The destination for the grouped files.
            groupOrder : list[str]
                #: The list of group names, first element is outermost group.
        Kwargs:
        -------    
            keywords : list[str] : default=None
                #: The list of keyword strings to search for.
            
        &#39;&#39;&#39;   
        
        # Methods that perform each grouping 
        self.groupMethods = {
            &#34;Type&#34;:GroupByType, 
            &#34;Subtype&#34;:GroupBySubtype, 
            &#34;Dummy&#34;:TestGroup, 
            &#34;Keyword&#34;:GroupByKeyword
        }
        # Destination for the group folders (first in hierarchy)
        self.destination = ParsePath(destination)
        # Grouping hierarchy
        self.groupOrder = groupOrder
        # Keywords (if required)
        if(keywords):
            self.keywords = keywords


        # ----- GROUPER RESULTS ---- #
        self.previewPathDict = dict()
        self.groupStructureDict = dict()</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fileorganiser" href="index.html">fileorganiser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="grouper.SORT_GROUPS" href="#grouper.SORT_GROUPS">SORT_GROUPS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="grouper.AppendNestedSubgroups" href="#grouper.AppendNestedSubgroups">AppendNestedSubgroups</a></code></li>
<li><code><a title="grouper.BuildPreviewJsTreeJson" href="#grouper.BuildPreviewJsTreeJson">BuildPreviewJsTreeJson</a></code></li>
<li><code><a title="grouper.CreateAllNestedFolders" href="#grouper.CreateAllNestedFolders">CreateAllNestedFolders</a></code></li>
<li><code><a title="grouper.CreateAllNestedGroups" href="#grouper.CreateAllNestedGroups">CreateAllNestedGroups</a></code></li>
<li><code><a title="grouper.CreateGrouperBackup" href="#grouper.CreateGrouperBackup">CreateGrouperBackup</a></code></li>
<li><code><a title="grouper.CreateNestedGroupFolders" href="#grouper.CreateNestedGroupFolders">CreateNestedGroupFolders</a></code></li>
<li><code><a title="grouper.FileGrouperMain_Preview" href="#grouper.FileGrouperMain_Preview">FileGrouperMain_Preview</a></code></li>
<li><code><a title="grouper.FileGrouperMain_Verified" href="#grouper.FileGrouperMain_Verified">FileGrouperMain_Verified</a></code></li>
<li><code><a title="grouper.GroupByKeyword" href="#grouper.GroupByKeyword">GroupByKeyword</a></code></li>
<li><code><a title="grouper.GroupBySubtype" href="#grouper.GroupBySubtype">GroupBySubtype</a></code></li>
<li><code><a title="grouper.GroupByType" href="#grouper.GroupByType">GroupByType</a></code></li>
<li><code><a title="grouper.MoveFilesIntoGroups" href="#grouper.MoveFilesIntoGroups">MoveFilesIntoGroups</a></code></li>
<li><code><a title="grouper.RestoreGroupedFilesFromBackup" href="#grouper.RestoreGroupedFilesFromBackup">RestoreGroupedFilesFromBackup</a></code></li>
<li><code><a title="grouper.TestGroup" href="#grouper.TestGroup">TestGroup</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="grouper.Grouper" href="#grouper.Grouper">Grouper</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>